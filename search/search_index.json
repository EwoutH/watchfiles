{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"watchfiles \u00b6 Documentation for version: v0.18.0 . Simple, modern and high performance file watching and code reload in python. Underlying file system notifications are handled by the Notify rust library. This package was previously named \"watchgod\", see Migrating from watchgod for more information. Usage \u00b6 Here are some examples of what watchfiles can do: watch Usage from watchfiles import watch for changes in watch ( './path/to/dir' ): print ( changes ) See watch docs for more details. watch (and all other methods) can watch either files or directories and can watch more than one path with a single instance. awatch Usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( '/path/to/dir' ): print ( changes ) asyncio . run ( main ()) See awatch docs for more details. run_process Usage from watchfiles import run_process def foobar ( a , b , c ): ... if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) See run_process docs for more details. arun_process Usage import asyncio from watchfiles import arun_process def foobar ( a , b , c ): ... async def main (): await arun_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) if __name__ == '__main__' : asyncio . run ( main ()) See arun_process docs for more details. Installation \u00b6 watchfiles requires Python 3.7 to Python 3.10 . From PyPI \u00b6 Using pip : pip install watchfiles Binaries are available for: Linux : x86_64 , aarch64 , i686 , armv7l , musl-x86_64 & musl-aarch64 MacOS : x86_64 & arm64 (except python 3.7) Windows : amd64 & win32 From conda-forge \u00b6 Using conda or mamba : mamba install -c conda-forge watchfiles Binaries are available for: Linux : x86_64 MacOS : x86_64 & arm64 (except python 3.7) Windows : amd64 From source \u00b6 You can also install from source which requires Rust stable to be installed. How Watchfiles Works \u00b6 watchfiles is based on the Notify rust library. All the hard work of integrating with the OS's file system events notifications and falling back to polling is palmed off onto the rust library. \"Debouncing\" changes - e.g. grouping changes into batches rather than firing a yield/reload for each file changed is managed in rust. The rust code takes care of creating a new thread to watch for file changes so in the case of the synchronous methods ( watch and run_process ) no threading logic is required in python. When using the asynchronous methods ( awatch and arun_process ) anyio.to_thread.run_sync is used to wait for changes in a thread.","title":"Introduction"},{"location":"#watchfiles","text":"Documentation for version: v0.18.0 . Simple, modern and high performance file watching and code reload in python. Underlying file system notifications are handled by the Notify rust library. This package was previously named \"watchgod\", see Migrating from watchgod for more information.","title":"watchfiles"},{"location":"#usage","text":"Here are some examples of what watchfiles can do: watch Usage from watchfiles import watch for changes in watch ( './path/to/dir' ): print ( changes ) See watch docs for more details. watch (and all other methods) can watch either files or directories and can watch more than one path with a single instance. awatch Usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( '/path/to/dir' ): print ( changes ) asyncio . run ( main ()) See awatch docs for more details. run_process Usage from watchfiles import run_process def foobar ( a , b , c ): ... if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) See run_process docs for more details. arun_process Usage import asyncio from watchfiles import arun_process def foobar ( a , b , c ): ... async def main (): await arun_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) if __name__ == '__main__' : asyncio . run ( main ()) See arun_process docs for more details.","title":"Usage"},{"location":"#installation","text":"watchfiles requires Python 3.7 to Python 3.10 .","title":"Installation"},{"location":"#from-pypi","text":"Using pip : pip install watchfiles Binaries are available for: Linux : x86_64 , aarch64 , i686 , armv7l , musl-x86_64 & musl-aarch64 MacOS : x86_64 & arm64 (except python 3.7) Windows : amd64 & win32","title":"From PyPI"},{"location":"#from-conda-forge","text":"Using conda or mamba : mamba install -c conda-forge watchfiles Binaries are available for: Linux : x86_64 MacOS : x86_64 & arm64 (except python 3.7) Windows : amd64","title":"From conda-forge"},{"location":"#from-source","text":"You can also install from source which requires Rust stable to be installed.","title":"From source"},{"location":"#how-watchfiles-works","text":"watchfiles is based on the Notify rust library. All the hard work of integrating with the OS's file system events notifications and falling back to polling is palmed off onto the rust library. \"Debouncing\" changes - e.g. grouping changes into batches rather than firing a yield/reload for each file changed is managed in rust. The rust code takes care of creating a new thread to watch for file changes so in the case of the synchronous methods ( watch and run_process ) no threading logic is required in python. When using the asynchronous methods ( awatch and arun_process ) anyio.to_thread.run_sync is used to wait for changes in a thread.","title":"How Watchfiles Works"},{"location":"cli/","text":"watchfiles comes with a CLI for running and reloading code, the CLI uses watchfiles.run_process to run the code and like run_process can either run a python function or a shell-like command. The CLI can be used either via watchfiles ... or python -m watchfiles ... . Running and restarting a python function \u00b6 Let's say you have foobar.py (in this case a very simple web server using aiohttp ) which gets details about recent file changes from the WATCHFILES_CHANGES environment variable (see run_process docs ) and returns them as JSON. foobar.py import os , json from aiohttp import web async def handle ( request ): # get the most recent file changes and return them changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) return web . json_response ( dict ( changes = changes )) app = web . Application () app . router . add_get ( '/' , handle ) def main (): web . run_app ( app , port = 8000 ) You could run this and reload it when any file in the current directory changes with: Running a python function watchfiles foobar.main Running and restarting a command \u00b6 Let's say you want to re-run failing tests whenever files change. You could do this with watchfiles using Running a command watchfiles 'pytest --lf' (pytest's --lf option is a shortcut for --last-failed , see pytest docs ) By default the CLI will watch the current directory and all subdirectories, but the directory/directories watched can be changed. In this example, we might want to watch only the src and tests directories, and only react to changes in python files: Watching custom directories and files watchfiles --filter python 'pytest --lf' src tests Help \u00b6 Run watchfiles --help for more options. watchfiles --help usage: watchfiles [-h] [--ignore-paths [IGNORE_PATHS]] [--target-type [{command,function,auto}]] [--filter [FILTER]] [--args [ARGS]] [--verbose] [--non-recursive] [--verbosity [{warning,info,debug}]] [--sigint-timeout [SIGINT_TIMEOUT]] [--sigkill-timeout [SIGKILL_TIMEOUT]] [--version] target [paths ...] Watch one or more directories and execute either a shell command or a python function on file changes. Example of watching the current directory and calling a python function: watchfiles foobar.main Example of watching python files in two local directories and calling a shell command: watchfiles --filter python 'pytest --lf' src tests See https://watchfiles.helpmanual.io/cli/ for more information. positional arguments: target Command or dotted function path to run paths Filesystem paths to watch, defaults to current directory options: -h, --help show this help message and exit --ignore-paths [IGNORE_PATHS] Specify directories to ignore, to ignore multiple paths use a comma as separator, e.g. \"env\" or \"env,node_modules\" --target-type [{command,function,auto}] Whether the target should be intercepted as a shell command or a python function, defaults to \"auto\" which infers the target type from the target string --filter [FILTER] Which files to watch, defaults to \"default\" which uses the \"DefaultFilter\", \"python\" uses the \"PythonFilter\", \"all\" uses no filter, any other value is interpreted as a python function/class path which is imported --args [ARGS] Arguments to set on sys.argv before calling target function, used only if the target is a function --verbose Set log level to \"debug\", wins over `--verbosity` --non-recursive Do not watch for changes in sub-directories recursively --verbosity [{warning,info,debug}] Log level, defaults to \"info\" --sigint-timeout [SIGINT_TIMEOUT] How long to wait for the sigint timeout before sending sigkill. --sigkill-timeout [SIGKILL_TIMEOUT] How long to wait for the sigkill timeout before issuing a timeout exception. --version, -V show program's version number and exit","title":"CLI"},{"location":"cli/#running-and-restarting-a-python-function","text":"Let's say you have foobar.py (in this case a very simple web server using aiohttp ) which gets details about recent file changes from the WATCHFILES_CHANGES environment variable (see run_process docs ) and returns them as JSON. foobar.py import os , json from aiohttp import web async def handle ( request ): # get the most recent file changes and return them changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) return web . json_response ( dict ( changes = changes )) app = web . Application () app . router . add_get ( '/' , handle ) def main (): web . run_app ( app , port = 8000 ) You could run this and reload it when any file in the current directory changes with: Running a python function watchfiles foobar.main","title":"Running and restarting a python function"},{"location":"cli/#running-and-restarting-a-command","text":"Let's say you want to re-run failing tests whenever files change. You could do this with watchfiles using Running a command watchfiles 'pytest --lf' (pytest's --lf option is a shortcut for --last-failed , see pytest docs ) By default the CLI will watch the current directory and all subdirectories, but the directory/directories watched can be changed. In this example, we might want to watch only the src and tests directories, and only react to changes in python files: Watching custom directories and files watchfiles --filter python 'pytest --lf' src tests","title":"Running and restarting a command"},{"location":"cli/#help","text":"Run watchfiles --help for more options. watchfiles --help usage: watchfiles [-h] [--ignore-paths [IGNORE_PATHS]] [--target-type [{command,function,auto}]] [--filter [FILTER]] [--args [ARGS]] [--verbose] [--non-recursive] [--verbosity [{warning,info,debug}]] [--sigint-timeout [SIGINT_TIMEOUT]] [--sigkill-timeout [SIGKILL_TIMEOUT]] [--version] target [paths ...] Watch one or more directories and execute either a shell command or a python function on file changes. Example of watching the current directory and calling a python function: watchfiles foobar.main Example of watching python files in two local directories and calling a shell command: watchfiles --filter python 'pytest --lf' src tests See https://watchfiles.helpmanual.io/cli/ for more information. positional arguments: target Command or dotted function path to run paths Filesystem paths to watch, defaults to current directory options: -h, --help show this help message and exit --ignore-paths [IGNORE_PATHS] Specify directories to ignore, to ignore multiple paths use a comma as separator, e.g. \"env\" or \"env,node_modules\" --target-type [{command,function,auto}] Whether the target should be intercepted as a shell command or a python function, defaults to \"auto\" which infers the target type from the target string --filter [FILTER] Which files to watch, defaults to \"default\" which uses the \"DefaultFilter\", \"python\" uses the \"PythonFilter\", \"all\" uses no filter, any other value is interpreted as a python function/class path which is imported --args [ARGS] Arguments to set on sys.argv before calling target function, used only if the target is a function --verbose Set log level to \"debug\", wins over `--verbosity` --non-recursive Do not watch for changes in sub-directories recursively --verbosity [{warning,info,debug}] Log level, defaults to \"info\" --sigint-timeout [SIGINT_TIMEOUT] How long to wait for the sigint timeout before sending sigkill. --sigkill-timeout [SIGKILL_TIMEOUT] How long to wait for the sigkill timeout before issuing a timeout exception. --version, -V show program's version number and exit","title":"Help"},{"location":"migrating/","text":"This package was significantly rewritten and renamed from watchgod to watchfiles , these docs refer to the new watchfiles package. The main reason for this change was to avoid confusion with the similarly named \"watchdog\" package, see #102 for more details. The most significant code change was to switch from file scanning/polling to OS file system notifications using the Notify rust library. This is much more performant than the old approach. As a result, the external interface to the library has been changed somewhat. The main methods: watch awatch run_process arun_process All remain, the following changes affect them all: watcher_cls is removed and replaced by watch_filter which should be a simple callable, see filter docs all these methods allow multiple paths to be watched, as result, the target argument to run_process & arun_process is now keyword-only the other optional keyword arguments have changed somewhat, mostly as a result of cleanup, all public methods are now thoroughly documented The old watchgod package remains \u00b6 The old watchgod pypi package remains, I'll add a notice about the new package name, but otherwise It'll continue to work (in future, it might get deprecation warnings). Documentation is available in the old README .","title":"Migration from watchgod"},{"location":"migrating/#the-old-watchgod-package-remains","text":"The old watchgod pypi package remains, I'll add a notice about the new package name, but otherwise It'll continue to work (in future, it might get deprecation warnings). Documentation is available in the old README .","title":"The old watchgod package remains"},{"location":"api/filters/","text":"All classes described here are designed to be used for the watch_filter argument to the watch function and similar. This argument requires a simple callable which takes two arguments (the Change type and the path as a string) and returns a boolean indicating if the change should be included ( True ) or ignored ( False ). As shown below in Custom Filters , you can either a BaseFilter subclass instance or your own callable. BaseFilter \u00b6 Useful base class for creating filters. BaseFilter should be inherited and configured, rather than used directly. The class supports ignoring files in 3 ways: ignore_dirs class-attribute \u00b6 ignore_dirs : Sequence [ str ] = () Full names of directories to ignore, an obvious example would be .git . ignore_entity_patterns class-attribute \u00b6 ignore_entity_patterns : Sequence [ str ] = () Patterns of files or directories to ignore, these are compiled into regexes. \"entity\" here refers to the specific file or directory - basically the result of path.split(os.sep)[-1] , an obvious example would be r'\\.py[cod]$' . ignore_paths class-attribute \u00b6 ignore_paths : Sequence [ Union [ str , Path ]] = () Full paths to ignore, e.g. /home/users/.cache or C:\\Users\\user\\.cache . __call__ \u00b6 __call__ ( change : Change , path : str ) -> bool Instances of BaseFilter subclasses can be used as callables. Parameters: Name Type Description Default change Change The type of change that occurred, see Change . required path str the raw path of the file or directory that changed. required Returns: Type Description bool True if the file should be included in changes, False if it should be ignored. DefaultFilter \u00b6 DefaultFilter ( * , ignore_dirs : Optional [ Sequence [ str ]] = None , ignore_entity_patterns : Optional [ Sequence [ str ]] = None , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None ) -> None Bases: BaseFilter The default filter, which ignores files and directories that you might commonly want to ignore. Parameters: Name Type Description Default ignore_dirs Optional [ Sequence [ str ]] if not None , overrides the ignore_dirs value set on the class. None ignore_entity_patterns Optional [ Sequence [ str ]] if not None , overrides the ignore_entity_patterns value set on the class. None ignore_paths Optional [ Sequence [ Union [ str , Path ]]] if not None , overrides the ignore_paths value set on the class. None ignore_dirs class-attribute \u00b6 ignore_dirs : Sequence [ str ] = ( \"__pycache__\" , \".git\" , \".hg\" , \".svn\" , \".tox\" , \".venv\" , \"site-packages\" , \".idea\" , \"node_modules\" , \".mypy_cache\" , \".pytest_cache\" , \".hypothesis\" , ) Directory names to ignore. ignore_entity_patterns class-attribute \u00b6 ignore_entity_patterns : Sequence [ str ] = ( \" \\\\ .py[cod]$\" , \" \\\\ .___jb_...___$\" , \" \\\\ .sw.$\" , \"~$\" , \"^ \\\\ . \\\\ #\" , \"^ \\\\ .DS_Store$\" , \"^flycheck_\" , ) File/Directory name patterns to ignore. PythonFilter \u00b6 PythonFilter ( * , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None , extra_extensions : Sequence [ str ] = () ) -> None Bases: DefaultFilter A filter for Python files, since this class inherits from DefaultFilter it will ignore files and directories that you might commonly want to ignore as well as filtering out all changes except in Python files (files with extensions ('.py', '.pyx', '.pyd') ). Parameters: Name Type Description Default ignore_paths Optional [ Sequence [ Union [ str , Path ]]] The paths to ignore, see BaseFilter . None extra_extensions Sequence [ str ] extra extensions to ignore. () ignore_paths and extra_extensions can be passed as arguments partly to support CLI usage where --ignore-paths and --extensions can be passed as arguments. Custom Filters \u00b6 Here's an example of a custom filter which extends DefaultFilter to only notice changes to common web files: from watchfiles import Change , DefaultFilter , watch class WebFilter ( DefaultFilter ): allowed_extensions = '.html' , '.css' , '.js' def __call__ ( self , change : Change , path : str ) -> bool : return ( super () . __call__ ( change , path ) and path . endswith ( self . allowed_extensions ) ) for changes in watch ( 'my/web/project' , watch_filter = WebFilter ()): print ( changes ) Here's an example of a customer filter which is a simple callable that ignores changes unless they represent a new file being created: from watchfiles import Change , watch def only_added ( change : Change , path : str ) -> bool : return change == Change . added for changes in watch ( 'my/project' , watch_filter = only_added ): print ( changes ) For more details, see filters.py .","title":"Filters"},{"location":"api/filters/#watchfiles.BaseFilter","text":"Useful base class for creating filters. BaseFilter should be inherited and configured, rather than used directly. The class supports ignoring files in 3 ways:","title":"BaseFilter"},{"location":"api/filters/#watchfiles.filters.BaseFilter.ignore_dirs","text":"ignore_dirs : Sequence [ str ] = () Full names of directories to ignore, an obvious example would be .git .","title":"ignore_dirs"},{"location":"api/filters/#watchfiles.filters.BaseFilter.ignore_entity_patterns","text":"ignore_entity_patterns : Sequence [ str ] = () Patterns of files or directories to ignore, these are compiled into regexes. \"entity\" here refers to the specific file or directory - basically the result of path.split(os.sep)[-1] , an obvious example would be r'\\.py[cod]$' .","title":"ignore_entity_patterns"},{"location":"api/filters/#watchfiles.filters.BaseFilter.ignore_paths","text":"ignore_paths : Sequence [ Union [ str , Path ]] = () Full paths to ignore, e.g. /home/users/.cache or C:\\Users\\user\\.cache .","title":"ignore_paths"},{"location":"api/filters/#watchfiles.filters.BaseFilter.__call__","text":"__call__ ( change : Change , path : str ) -> bool Instances of BaseFilter subclasses can be used as callables. Parameters: Name Type Description Default change Change The type of change that occurred, see Change . required path str the raw path of the file or directory that changed. required Returns: Type Description bool True if the file should be included in changes, False if it should be ignored.","title":"__call__()"},{"location":"api/filters/#watchfiles.DefaultFilter","text":"DefaultFilter ( * , ignore_dirs : Optional [ Sequence [ str ]] = None , ignore_entity_patterns : Optional [ Sequence [ str ]] = None , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None ) -> None Bases: BaseFilter The default filter, which ignores files and directories that you might commonly want to ignore. Parameters: Name Type Description Default ignore_dirs Optional [ Sequence [ str ]] if not None , overrides the ignore_dirs value set on the class. None ignore_entity_patterns Optional [ Sequence [ str ]] if not None , overrides the ignore_entity_patterns value set on the class. None ignore_paths Optional [ Sequence [ Union [ str , Path ]]] if not None , overrides the ignore_paths value set on the class. None","title":"DefaultFilter"},{"location":"api/filters/#watchfiles.filters.DefaultFilter.ignore_dirs","text":"ignore_dirs : Sequence [ str ] = ( \"__pycache__\" , \".git\" , \".hg\" , \".svn\" , \".tox\" , \".venv\" , \"site-packages\" , \".idea\" , \"node_modules\" , \".mypy_cache\" , \".pytest_cache\" , \".hypothesis\" , ) Directory names to ignore.","title":"ignore_dirs"},{"location":"api/filters/#watchfiles.filters.DefaultFilter.ignore_entity_patterns","text":"ignore_entity_patterns : Sequence [ str ] = ( \" \\\\ .py[cod]$\" , \" \\\\ .___jb_...___$\" , \" \\\\ .sw.$\" , \"~$\" , \"^ \\\\ . \\\\ #\" , \"^ \\\\ .DS_Store$\" , \"^flycheck_\" , ) File/Directory name patterns to ignore.","title":"ignore_entity_patterns"},{"location":"api/filters/#watchfiles.PythonFilter","text":"PythonFilter ( * , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None , extra_extensions : Sequence [ str ] = () ) -> None Bases: DefaultFilter A filter for Python files, since this class inherits from DefaultFilter it will ignore files and directories that you might commonly want to ignore as well as filtering out all changes except in Python files (files with extensions ('.py', '.pyx', '.pyd') ). Parameters: Name Type Description Default ignore_paths Optional [ Sequence [ Union [ str , Path ]]] The paths to ignore, see BaseFilter . None extra_extensions Sequence [ str ] extra extensions to ignore. () ignore_paths and extra_extensions can be passed as arguments partly to support CLI usage where --ignore-paths and --extensions can be passed as arguments.","title":"PythonFilter"},{"location":"api/filters/#custom-filters","text":"Here's an example of a custom filter which extends DefaultFilter to only notice changes to common web files: from watchfiles import Change , DefaultFilter , watch class WebFilter ( DefaultFilter ): allowed_extensions = '.html' , '.css' , '.js' def __call__ ( self , change : Change , path : str ) -> bool : return ( super () . __call__ ( change , path ) and path . endswith ( self . allowed_extensions ) ) for changes in watch ( 'my/web/project' , watch_filter = WebFilter ()): print ( changes ) Here's an example of a customer filter which is a simple callable that ignores changes unless they represent a new file being created: from watchfiles import Change , watch def only_added ( change : Change , path : str ) -> bool : return change == Change . added for changes in watch ( 'my/project' , watch_filter = only_added ): print ( changes ) For more details, see filters.py .","title":"Custom Filters"},{"location":"api/run_process/","text":"run_process \u00b6 run_process ( * paths : Union [ Path , str ], target : Union [ str , Callable [ ... , Any ]], args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , target_type : Literal [ \"function\" , \"command\" , \"auto\" ] = \"auto\" , callback : Optional [ Callable [[ Set [ FileChange ]], None ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False , sigint_timeout : int = 5 , sigkill_timeout : int = 1 , recursive : bool = True ) -> int Run a process and restart it upon file changes. run_process can work in two ways: Using multiprocessing.Process \u2020 to run a python function Or, using subprocess.Popen to run a command Note \u2020 technically multiprocessing.get_context('spawn').Process to avoid forking and improve code reload/import. Internally, run_process uses watch with raise_interrupt=False so the function exits cleanly upon Ctrl+C . Parameters: Name Type Description Default *paths Union [ Path , str ] matches the same argument of watch () target Union [ str , Callable [..., Any ]] function or command to run required args Tuple [ Any , ...] arguments to pass to target , only used if target is a function () kwargs Optional [ Dict [ str , Any ]] keyword arguments to pass to target , only used if target is a function None target_type Literal['function', 'command', 'auto'] type of target. Can be 'function' , 'command' , or 'auto' in which case detect_target_type is used to determine the type. 'auto' callback Optional [ Callable [[ Set [ FileChange ]], None]] function to call on each reload, the function should accept a set of changes as the sole argument None watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch DefaultFilter() debounce int matches the same argument of watch 1600 step int matches the same argument of watch 50 debug bool matches the same argument of watch False sigint_timeout int the number of seconds to wait after sending sigint before sending sigkill 5 sigkill_timeout int the number of seconds to wait after sending sigkill before raising an exception 1 recursive bool matches the same argument of watch True Returns: Type Description int number of times the function was reloaded. Example of run_process running a function from watchfiles import run_process def callback ( changes ): print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 ), callback = callback ) As well as using a callback function, changes can be accessed from within the target function, using the WATCHFILES_CHANGES environment variable. Example of run_process accessing changes from watchfiles import run_process def foobar ( a , b , c ): # changes will be an empty list \"[]\" the first time the function is called changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) print ( 'foobar called due to changes:' , changes ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) Again with the target as command , WATCHFILES_CHANGES can be used to access changes. example.sh echo \"changers: ${ WATCHFILES_CHANGES } \" Example of run_process running a command from watchfiles import run_process if __name__ == '__main__' : run_process ( '.' , target = './example.sh' ) arun_process async \u00b6 arun_process ( * paths : Union [ Path , str ], target : Union [ str , Callable [ ... , Any ]], args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , target_type : Literal [ \"function\" , \"command\" , \"auto\" ] = \"auto\" , callback : Optional [ Callable [[ Set [ FileChange ]], Any ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False , recursive : bool = True ) -> int Async equivalent of run_process , all arguments match those of run_process except callback which can be a coroutine. Starting and stopping the process and watching for changes is done in a separate thread. As with run_process , internally arun_process uses awatch , however KeyboardInterrupt cannot be caught and suppressed in awatch so these errors need to be caught separately, see below. Example of arun_process usage import asyncio from watchfiles import arun_process async def callback ( changes ): await asyncio . sleep ( 0.1 ) print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) async def main (): await arun_process ( '.' , target = foobar , args = ( 1 , 2 ), callback = callback ) if __name__ == '__main__' : try : asyncio . run ( main ()) except KeyboardInterrupt : print ( 'stopped via KeyboardInterrupt' ) detect_target_type \u00b6 detect_target_type ( target : Union [ str , Callable [ ... , Any ]] ) -> Literal [ \"function\" , \"command\" ] Used by run_process , arun_process and indirectly the CLI to determine the target type with target_type is auto . Detects the target type - either function or command . This method is only called with target_type='auto' . The following logic is employed: If target is not a string, it is assumed to be a function If target ends with .py or .sh , it is assumed to be a command Otherwise, the target is assumed to be a function if it matches the regex [a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)+ If this logic does not work for you, specify the target type explicitly using the target_type function argument or --target-type command line argument. Parameters: Name Type Description Default target Union [ str , Callable [..., Any ]] The target value required Returns: Type Description Literal['function', 'command'] either 'function' or 'command'","title":"Run process"},{"location":"api/run_process/#watchfiles.run_process","text":"run_process ( * paths : Union [ Path , str ], target : Union [ str , Callable [ ... , Any ]], args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , target_type : Literal [ \"function\" , \"command\" , \"auto\" ] = \"auto\" , callback : Optional [ Callable [[ Set [ FileChange ]], None ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False , sigint_timeout : int = 5 , sigkill_timeout : int = 1 , recursive : bool = True ) -> int Run a process and restart it upon file changes. run_process can work in two ways: Using multiprocessing.Process \u2020 to run a python function Or, using subprocess.Popen to run a command Note \u2020 technically multiprocessing.get_context('spawn').Process to avoid forking and improve code reload/import. Internally, run_process uses watch with raise_interrupt=False so the function exits cleanly upon Ctrl+C . Parameters: Name Type Description Default *paths Union [ Path , str ] matches the same argument of watch () target Union [ str , Callable [..., Any ]] function or command to run required args Tuple [ Any , ...] arguments to pass to target , only used if target is a function () kwargs Optional [ Dict [ str , Any ]] keyword arguments to pass to target , only used if target is a function None target_type Literal['function', 'command', 'auto'] type of target. Can be 'function' , 'command' , or 'auto' in which case detect_target_type is used to determine the type. 'auto' callback Optional [ Callable [[ Set [ FileChange ]], None]] function to call on each reload, the function should accept a set of changes as the sole argument None watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch DefaultFilter() debounce int matches the same argument of watch 1600 step int matches the same argument of watch 50 debug bool matches the same argument of watch False sigint_timeout int the number of seconds to wait after sending sigint before sending sigkill 5 sigkill_timeout int the number of seconds to wait after sending sigkill before raising an exception 1 recursive bool matches the same argument of watch True Returns: Type Description int number of times the function was reloaded. Example of run_process running a function from watchfiles import run_process def callback ( changes ): print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 ), callback = callback ) As well as using a callback function, changes can be accessed from within the target function, using the WATCHFILES_CHANGES environment variable. Example of run_process accessing changes from watchfiles import run_process def foobar ( a , b , c ): # changes will be an empty list \"[]\" the first time the function is called changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) print ( 'foobar called due to changes:' , changes ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) Again with the target as command , WATCHFILES_CHANGES can be used to access changes. example.sh echo \"changers: ${ WATCHFILES_CHANGES } \" Example of run_process running a command from watchfiles import run_process if __name__ == '__main__' : run_process ( '.' , target = './example.sh' )","title":"run_process()"},{"location":"api/run_process/#watchfiles.arun_process","text":"arun_process ( * paths : Union [ Path , str ], target : Union [ str , Callable [ ... , Any ]], args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , target_type : Literal [ \"function\" , \"command\" , \"auto\" ] = \"auto\" , callback : Optional [ Callable [[ Set [ FileChange ]], Any ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False , recursive : bool = True ) -> int Async equivalent of run_process , all arguments match those of run_process except callback which can be a coroutine. Starting and stopping the process and watching for changes is done in a separate thread. As with run_process , internally arun_process uses awatch , however KeyboardInterrupt cannot be caught and suppressed in awatch so these errors need to be caught separately, see below. Example of arun_process usage import asyncio from watchfiles import arun_process async def callback ( changes ): await asyncio . sleep ( 0.1 ) print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) async def main (): await arun_process ( '.' , target = foobar , args = ( 1 , 2 ), callback = callback ) if __name__ == '__main__' : try : asyncio . run ( main ()) except KeyboardInterrupt : print ( 'stopped via KeyboardInterrupt' )","title":"arun_process()"},{"location":"api/run_process/#watchfiles.run.detect_target_type","text":"detect_target_type ( target : Union [ str , Callable [ ... , Any ]] ) -> Literal [ \"function\" , \"command\" ] Used by run_process , arun_process and indirectly the CLI to determine the target type with target_type is auto . Detects the target type - either function or command . This method is only called with target_type='auto' . The following logic is employed: If target is not a string, it is assumed to be a function If target ends with .py or .sh , it is assumed to be a command Otherwise, the target is assumed to be a function if it matches the regex [a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)+ If this logic does not work for you, specify the target type explicitly using the target_type function argument or --target-type command line argument. Parameters: Name Type Description Default target Union [ str , Callable [..., Any ]] The target value required Returns: Type Description Literal['function', 'command'] either 'function' or 'command'","title":"detect_target_type()"},{"location":"api/rust_backend/","text":"RustNotify \u00b6 RustNotify ( watch_paths : List [ str ], debug : bool , force_polling : bool , poll_delay_ms : int , recursive : bool , ) -> None Interface to the Rust notify crate which does the heavy lifting of watching for file changes and grouping them into events. Create a new RustNotify instance and start a thread to watch for changes. FileNotFoundError is raised if any of the paths do not exist. Parameters: Name Type Description Default watch_paths List [ str ] file system paths to watch for changes, can be directories or files required debug bool if true, print details about all events to stderr required force_polling bool if true, always use polling instead of file system notifications required poll_delay_ms int delay between polling for changes, only used if force_polling=True required recursive bool if True , watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is True . required __enter__ \u00b6 __enter__ () -> RustNotify Does nothing, but allows RustNotify to be used as a context manager. Note The watching thead is created when an instance is initiated, not on __enter__ . __exit__ \u00b6 __exit__ ( * args : Any ) -> None Calls close . close \u00b6 close () -> None Stops the watching thread. After close is called, the RustNotify instance can no longer be used, calls to watch will raise a RuntimeError . Note close is not required, just deleting the RustNotify instance will kill the thread implicitly. As per #163 close() is only required because in the event of an error, the traceback in sys.exc_info keeps a reference to watchfiles.watch 's frame, so you can't rely on the RustNotify object being deleted, and thereby stopping the watching thread. watch \u00b6 watch ( debounce_ms : int , step_ms : int , timeout_ms : int , stop_event : Optional [ AbstractEvent ], ) -> Union [ Set [ Tuple [ int , str ]], Literal [ \"signal\" , \"stop\" , \"timeout\" ], ] Watch for changes. This method will wait timeout_ms milliseconds for changes, but once a change is detected, it will group changes and return in no more than debounce_ms milliseconds. The GIL is released during a step_ms sleep on each iteration to avoid blocking python. Parameters: Name Type Description Default debounce_ms int maximum time in milliseconds to group changes over before returning. required step_ms int time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. required timeout_ms int maximum time in milliseconds to wait for changes before returning, 0 means wait indefinitely, debounce_ms takes precedence over timeout_ms once a change is detected. required stop_event Optional [ AbstractEvent ] event to check on every iteration to see if this function should return early. The event should be an object which has an is_set() method which returns a boolean. required Returns: Type Description Union [ Set [ Tuple [ int , str ]], Literal ['signal', 'stop', 'timeout']] See below. Return values have the following meanings: Change details as a set of (event_type, path) tuples, the event types are ints which match Change , path is a string representing the path of the file that changed 'signal' string, if a signal was received 'stop' string, if the stop_event was set 'timeout' string, if timeout_ms was exceeded WatchfilesRustInternalError \u00b6 Bases: RuntimeError Raised when RustNotify encounters an unknown error. If you get this a lot, please check github issues and create a new issue if your problem is not discussed. __version__ module-attribute \u00b6 __version__ : str The package version as defined in Cargo.toml , modified to match python's versioning semantics. Rust backend direct usage \u00b6 The rust backend can be accessed directly as follows: Rust backend example from watchfiles._rust_notify import RustNotify r = RustNotify ([ 'first/path' , 'second/path' ], False , False , 0 , True ) changes = r . watch ( 1_600 , 50 , 100 , None ) print ( changes ) r . close () Or using RustNotify as a context manager: Rust backend context manager example from watchfiles._rust_notify import RustNotify with RustNotify ([ 'first/path' , 'second/path' ], False , False , 0 , True ) as r : changes = r . watch ( 1_600 , 50 , 100 , None ) print ( changes ) (See the documentation on close above for when and why the context manager or close method are required.)","title":"Rust backend"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify","text":"RustNotify ( watch_paths : List [ str ], debug : bool , force_polling : bool , poll_delay_ms : int , recursive : bool , ) -> None Interface to the Rust notify crate which does the heavy lifting of watching for file changes and grouping them into events. Create a new RustNotify instance and start a thread to watch for changes. FileNotFoundError is raised if any of the paths do not exist. Parameters: Name Type Description Default watch_paths List [ str ] file system paths to watch for changes, can be directories or files required debug bool if true, print details about all events to stderr required force_polling bool if true, always use polling instead of file system notifications required poll_delay_ms int delay between polling for changes, only used if force_polling=True required recursive bool if True , watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is True . required","title":"RustNotify"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__enter__","text":"__enter__ () -> RustNotify Does nothing, but allows RustNotify to be used as a context manager. Note The watching thead is created when an instance is initiated, not on __enter__ .","title":"__enter__()"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__exit__","text":"__exit__ ( * args : Any ) -> None Calls close .","title":"__exit__()"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.close","text":"close () -> None Stops the watching thread. After close is called, the RustNotify instance can no longer be used, calls to watch will raise a RuntimeError . Note close is not required, just deleting the RustNotify instance will kill the thread implicitly. As per #163 close() is only required because in the event of an error, the traceback in sys.exc_info keeps a reference to watchfiles.watch 's frame, so you can't rely on the RustNotify object being deleted, and thereby stopping the watching thread.","title":"close()"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.watch","text":"watch ( debounce_ms : int , step_ms : int , timeout_ms : int , stop_event : Optional [ AbstractEvent ], ) -> Union [ Set [ Tuple [ int , str ]], Literal [ \"signal\" , \"stop\" , \"timeout\" ], ] Watch for changes. This method will wait timeout_ms milliseconds for changes, but once a change is detected, it will group changes and return in no more than debounce_ms milliseconds. The GIL is released during a step_ms sleep on each iteration to avoid blocking python. Parameters: Name Type Description Default debounce_ms int maximum time in milliseconds to group changes over before returning. required step_ms int time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. required timeout_ms int maximum time in milliseconds to wait for changes before returning, 0 means wait indefinitely, debounce_ms takes precedence over timeout_ms once a change is detected. required stop_event Optional [ AbstractEvent ] event to check on every iteration to see if this function should return early. The event should be an object which has an is_set() method which returns a boolean. required Returns: Type Description Union [ Set [ Tuple [ int , str ]], Literal ['signal', 'stop', 'timeout']] See below. Return values have the following meanings: Change details as a set of (event_type, path) tuples, the event types are ints which match Change , path is a string representing the path of the file that changed 'signal' string, if a signal was received 'stop' string, if the stop_event was set 'timeout' string, if timeout_ms was exceeded","title":"watch()"},{"location":"api/rust_backend/#watchfiles._rust_notify.WatchfilesRustInternalError","text":"Bases: RuntimeError Raised when RustNotify encounters an unknown error. If you get this a lot, please check github issues and create a new issue if your problem is not discussed.","title":"WatchfilesRustInternalError"},{"location":"api/rust_backend/#watchfiles._rust_notify.__version__","text":"__version__ : str The package version as defined in Cargo.toml , modified to match python's versioning semantics.","title":"__version__"},{"location":"api/rust_backend/#rust-backend-direct-usage","text":"The rust backend can be accessed directly as follows: Rust backend example from watchfiles._rust_notify import RustNotify r = RustNotify ([ 'first/path' , 'second/path' ], False , False , 0 , True ) changes = r . watch ( 1_600 , 50 , 100 , None ) print ( changes ) r . close () Or using RustNotify as a context manager: Rust backend context manager example from watchfiles._rust_notify import RustNotify with RustNotify ([ 'first/path' , 'second/path' ], False , False , 0 , True ) as r : changes = r . watch ( 1_600 , 50 , 100 , None ) print ( changes ) (See the documentation on close above for when and why the context manager or close method are required.)","title":"Rust backend direct usage"},{"location":"api/watch/","text":"watch \u00b6 watch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , stop_event : Optional [ AbstractEvent ] = None , rust_timeout : int = 5000 , yield_on_timeout : bool = False , debug : bool = False , raise_interrupt : bool = True , force_polling : Optional [ bool ] = None , poll_delay_ms : int = 300 , recursive : bool = True ) -> Generator [ Set [ FileChange ], None , None ] Watch one or more paths and yield a set of changes whenever files change. The paths watched can be directories or files, directories are watched recursively - changes in subdirectories are also detected. Force polling \u00b6 Notify will fall back to file polling if it can't use file system notifications, but we also force notify to us polling if the force_polling argument is True ; if force_polling is unset (or None ), we enable force polling thus: if the WATCHFILES_FORCE_POLLING environment variable exists and is not empty: if the value is false , disable or disabled , force polling is disabled otherwise, force polling is enabled otherwise, we enable force polling only if we detect we're running on WSL (Windows Subsystem for Linux) Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem paths to watch. () watch_filter Optional [ Callable [[ Change , str ], bool ]] callable used to filter out changes which are not important, you can either use a raw callable or a BaseFilter instance, defaults to an instance of DefaultFilter . To keep all changes, use None . DefaultFilter() debounce int maximum time in milliseconds to group changes over before yielding them. 1600 step int time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. 50 stop_event Optional [ AbstractEvent ] event to stop watching, if this is set, the generator will stop iteration, this can be anything with an is_set() method which returns a bool, e.g. threading.Event() . None rust_timeout int maximum time in milliseconds to wait in the rust code for changes, 0 means no timeout. 5000 yield_on_timeout bool if True , the generator will yield upon timeout in rust even if no changes are detected. False debug bool whether to print information about all filesystem changes in rust to stdout. False raise_interrupt bool whether to re-raise KeyboardInterrupt s, or suppress the error and just stop iterating. True force_polling Optional [ bool ] See Force polling above. None poll_delay_ms int delay between polling for changes, only used if force_polling=True . 300 recursive bool if True , watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is True . True Yields: Type Description Generator [ Set [ FileChange ], None, None] The generator yields sets of FileChange s. Example of watch usage from watchfiles import watch for changes in watch ( './first/dir' , './second/dir' , raise_interrupt = False ): print ( changes ) awatch async \u00b6 awatch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , stop_event : Optional [ AnyEvent ] = None , rust_timeout : Optional [ int ] = None , yield_on_timeout : bool = False , debug : bool = False , raise_interrupt : Optional [ bool ] = None , force_polling : Optional [ bool ] = None , poll_delay_ms : int = 300 , recursive : bool = True ) -> AsyncGenerator [ Set [ FileChange ], None ] Asynchronous equivalent of watch using threads to wait for changes. Arguments match those of watch except stop_event . All async methods use anyio to run the event loop. Unlike watch KeyboardInterrupt cannot be suppressed by awatch so they need to be caught where asyncio.run or equivalent is called. Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem paths to watch. () watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch . DefaultFilter() debounce int matches the same argument of watch . 1600 step int matches the same argument of watch . 50 stop_event Optional [ AnyEvent ] anyio.Event which can be used to stop iteration, see example below. None rust_timeout Optional [ int ] matches the same argument of watch , except that None means use 1_000 on Windows and 5_000 on other platforms thus helping with exiting on Ctrl+C on Windows, see #110 . None yield_on_timeout bool matches the same argument of watch . False debug bool matches the same argument of watch . False raise_interrupt Optional [ bool ] This is deprecated, KeyboardInterrupt will cause this coroutine to be cancelled and then be raised by the top level asyncio.run call or equivalent, and should be caught there. See #136 None force_polling Optional [ bool ] if true, always use polling instead of file system notifications, default is None where force_polling is set to True if the WATCHFILES_FORCE_POLLING environment variable exists. None poll_delay_ms int delay between polling for changes, only used if force_polling=True . 300 recursive bool if True , watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is True . True Yields: Type Description AsyncGenerator [ Set [ FileChange ], None] The generator yields sets of FileChange s. Example of awatch usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( './first/dir' , './second/dir' ): print ( changes ) if __name__ == '__main__' : try : asyncio . run ( main ()) except KeyboardInterrupt : print ( 'stopped via KeyboardInterrupt' ) Example of awatch usage with a stop event import asyncio from watchfiles import awatch async def main (): stop_event = asyncio . Event () async def stop_soon (): await asyncio . sleep ( 3 ) stop_event . set () stop_soon_task = asyncio . create_task ( stop_soon ()) async for changes in awatch ( '/path/to/dir' , stop_event = stop_event ): print ( changes ) # cleanup by awaiting the (now complete) stop_soon_task await stop_soon_task asyncio . run ( main ()) Change \u00b6 Bases: IntEnum Enum representing the type of change that occurred. added class-attribute \u00b6 added = 1 A new file or directory was added. deleted class-attribute \u00b6 deleted = 3 A file or directory was deleted. modified class-attribute \u00b6 modified = 2 A file or directory was modified, can be either a metadata or data change. FileChange module-attribute \u00b6 FileChange = Tuple [ Change , str ] A tuple representing a file change, first element is a Change member, second is the path of the file or directory that changed.","title":"Watch"},{"location":"api/watch/#watchfiles.watch","text":"watch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , stop_event : Optional [ AbstractEvent ] = None , rust_timeout : int = 5000 , yield_on_timeout : bool = False , debug : bool = False , raise_interrupt : bool = True , force_polling : Optional [ bool ] = None , poll_delay_ms : int = 300 , recursive : bool = True ) -> Generator [ Set [ FileChange ], None , None ] Watch one or more paths and yield a set of changes whenever files change. The paths watched can be directories or files, directories are watched recursively - changes in subdirectories are also detected.","title":"watch()"},{"location":"api/watch/#watchfiles.watch--force-polling","text":"Notify will fall back to file polling if it can't use file system notifications, but we also force notify to us polling if the force_polling argument is True ; if force_polling is unset (or None ), we enable force polling thus: if the WATCHFILES_FORCE_POLLING environment variable exists and is not empty: if the value is false , disable or disabled , force polling is disabled otherwise, force polling is enabled otherwise, we enable force polling only if we detect we're running on WSL (Windows Subsystem for Linux) Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem paths to watch. () watch_filter Optional [ Callable [[ Change , str ], bool ]] callable used to filter out changes which are not important, you can either use a raw callable or a BaseFilter instance, defaults to an instance of DefaultFilter . To keep all changes, use None . DefaultFilter() debounce int maximum time in milliseconds to group changes over before yielding them. 1600 step int time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. 50 stop_event Optional [ AbstractEvent ] event to stop watching, if this is set, the generator will stop iteration, this can be anything with an is_set() method which returns a bool, e.g. threading.Event() . None rust_timeout int maximum time in milliseconds to wait in the rust code for changes, 0 means no timeout. 5000 yield_on_timeout bool if True , the generator will yield upon timeout in rust even if no changes are detected. False debug bool whether to print information about all filesystem changes in rust to stdout. False raise_interrupt bool whether to re-raise KeyboardInterrupt s, or suppress the error and just stop iterating. True force_polling Optional [ bool ] See Force polling above. None poll_delay_ms int delay between polling for changes, only used if force_polling=True . 300 recursive bool if True , watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is True . True Yields: Type Description Generator [ Set [ FileChange ], None, None] The generator yields sets of FileChange s. Example of watch usage from watchfiles import watch for changes in watch ( './first/dir' , './second/dir' , raise_interrupt = False ): print ( changes )","title":"Force polling"},{"location":"api/watch/#watchfiles.awatch","text":"awatch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , stop_event : Optional [ AnyEvent ] = None , rust_timeout : Optional [ int ] = None , yield_on_timeout : bool = False , debug : bool = False , raise_interrupt : Optional [ bool ] = None , force_polling : Optional [ bool ] = None , poll_delay_ms : int = 300 , recursive : bool = True ) -> AsyncGenerator [ Set [ FileChange ], None ] Asynchronous equivalent of watch using threads to wait for changes. Arguments match those of watch except stop_event . All async methods use anyio to run the event loop. Unlike watch KeyboardInterrupt cannot be suppressed by awatch so they need to be caught where asyncio.run or equivalent is called. Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem paths to watch. () watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch . DefaultFilter() debounce int matches the same argument of watch . 1600 step int matches the same argument of watch . 50 stop_event Optional [ AnyEvent ] anyio.Event which can be used to stop iteration, see example below. None rust_timeout Optional [ int ] matches the same argument of watch , except that None means use 1_000 on Windows and 5_000 on other platforms thus helping with exiting on Ctrl+C on Windows, see #110 . None yield_on_timeout bool matches the same argument of watch . False debug bool matches the same argument of watch . False raise_interrupt Optional [ bool ] This is deprecated, KeyboardInterrupt will cause this coroutine to be cancelled and then be raised by the top level asyncio.run call or equivalent, and should be caught there. See #136 None force_polling Optional [ bool ] if true, always use polling instead of file system notifications, default is None where force_polling is set to True if the WATCHFILES_FORCE_POLLING environment variable exists. None poll_delay_ms int delay between polling for changes, only used if force_polling=True . 300 recursive bool if True , watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is True . True Yields: Type Description AsyncGenerator [ Set [ FileChange ], None] The generator yields sets of FileChange s. Example of awatch usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( './first/dir' , './second/dir' ): print ( changes ) if __name__ == '__main__' : try : asyncio . run ( main ()) except KeyboardInterrupt : print ( 'stopped via KeyboardInterrupt' ) Example of awatch usage with a stop event import asyncio from watchfiles import awatch async def main (): stop_event = asyncio . Event () async def stop_soon (): await asyncio . sleep ( 3 ) stop_event . set () stop_soon_task = asyncio . create_task ( stop_soon ()) async for changes in awatch ( '/path/to/dir' , stop_event = stop_event ): print ( changes ) # cleanup by awaiting the (now complete) stop_soon_task await stop_soon_task asyncio . run ( main ())","title":"awatch()"},{"location":"api/watch/#watchfiles.Change","text":"Bases: IntEnum Enum representing the type of change that occurred.","title":"Change"},{"location":"api/watch/#watchfiles.main.Change.added","text":"added = 1 A new file or directory was added.","title":"added"},{"location":"api/watch/#watchfiles.main.Change.deleted","text":"deleted = 3 A file or directory was deleted.","title":"deleted"},{"location":"api/watch/#watchfiles.main.Change.modified","text":"modified = 2 A file or directory was modified, can be either a metadata or data change.","title":"modified"},{"location":"api/watch/#watchfiles.main.FileChange","text":"FileChange = Tuple [ Change , str ] A tuple representing a file change, first element is a Change member, second is the path of the file or directory that changed.","title":"FileChange"}]}