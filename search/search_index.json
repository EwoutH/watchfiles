{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"watchfiles \u00b6 Documentation for development version. Simple, modern and high performance file watching and code reload in python. Underlying file system notifications are handled by the Notify rust library. This package used to be called \"watchgod\", see Migrating from watchgod for more information. Usage \u00b6 Here are some examples of what watchfiles can do: watch Usage from watchfiles import watch for changes in watch ( './path/to/dir' ): print ( changes ) See watch docs for more details. awatch Usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( '/path/to/dir' ): print ( changes ) asyncio . run ( main ()) See awatch docs for more details. run_process Usage from watchfiles import run_process def foobar ( a , b , c ): ... if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) See run_process docs for more details. arun_process Usage import asyncio from watchfiles import arun_process def foobar ( a , b , c ): ... async def main (): await arun_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) if __name__ == '__main__' : asyncio . run ( main ()) See arun_process docs for more details. Installation \u00b6 watchfiles requires Python 3.7 to Python 3.10 . pip install watchfiles Binaries are available for: Linux : manylinux-x86_64 , musllinux-x86_64 & manylinux-i686 MacOS : x86_64 & arm64 (except python 3.7) Windows : amd64 & win32 Otherwise, you can install from source which requires Rust stable to be installed. How Watchfiles Works \u00b6 watchfiles is based on the Notify rust library. All the hard work of integrating with the OS's file system events notifications and falling back to polling is palmed off onto the rust library. \"Debouncing\" changes - e.g. grouping changes into batches rather than firing a yield/reload for each file changed is managed in rust. The rust code takes care of creating a new thread to watch for file changes so in the case of the synchronous methods ( watch and run_process ) no threading logic is required in python. When using the asynchronous methods ( awatch and arun_process ) anyio.to_thread.run_sync is used to wait for changes in a thread.","title":"Introduction"},{"location":"#watchfiles","text":"Documentation for development version. Simple, modern and high performance file watching and code reload in python. Underlying file system notifications are handled by the Notify rust library. This package used to be called \"watchgod\", see Migrating from watchgod for more information.","title":"watchfiles"},{"location":"#usage","text":"Here are some examples of what watchfiles can do: watch Usage from watchfiles import watch for changes in watch ( './path/to/dir' ): print ( changes ) See watch docs for more details. awatch Usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( '/path/to/dir' ): print ( changes ) asyncio . run ( main ()) See awatch docs for more details. run_process Usage from watchfiles import run_process def foobar ( a , b , c ): ... if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) See run_process docs for more details. arun_process Usage import asyncio from watchfiles import arun_process def foobar ( a , b , c ): ... async def main (): await arun_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) if __name__ == '__main__' : asyncio . run ( main ()) See arun_process docs for more details.","title":"Usage"},{"location":"#installation","text":"watchfiles requires Python 3.7 to Python 3.10 . pip install watchfiles Binaries are available for: Linux : manylinux-x86_64 , musllinux-x86_64 & manylinux-i686 MacOS : x86_64 & arm64 (except python 3.7) Windows : amd64 & win32 Otherwise, you can install from source which requires Rust stable to be installed.","title":"Installation"},{"location":"#how-watchfiles-works","text":"watchfiles is based on the Notify rust library. All the hard work of integrating with the OS's file system events notifications and falling back to polling is palmed off onto the rust library. \"Debouncing\" changes - e.g. grouping changes into batches rather than firing a yield/reload for each file changed is managed in rust. The rust code takes care of creating a new thread to watch for file changes so in the case of the synchronous methods ( watch and run_process ) no threading logic is required in python. When using the asynchronous methods ( awatch and arun_process ) anyio.to_thread.run_sync is used to wait for changes in a thread.","title":"How Watchfiles Works"},{"location":"cli/","text":"watchfiles also comes with a CLI for running and reloading python code. Let's say you have foobar.py (this is a very simple web server using aiohttp ) which gets details about recent file changes from the WATCHFILES_CHANGES see run_process docs environment variable and returns them as JSON. Code to be run via the CLI import os , json from aiohttp import web async def handle ( request ): # get the most recent file changes and return them changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) return web . json_response ( dict ( changes = changes )) app = web . Application () app . router . add_get ( '/' , handle ) def main (): web . run_app ( app , port = 8000 ) You could run this and reload it when any file in the current directory changes with: CLI Usage watchfiles foobar.main By default the CLI will watch the current directory and all subdirectories, but the directory/directories watched can be changed, this: CLI Usage with custom directories watchfiles foobar.main ./foo ./bar The CLI can also be used via python -m watchfiles ... . Help \u00b6 Run watchfiles --help for more options. watchfiles --help usage: watchfiles [-h] [--verbosity [VERBOSITY]] [--ignore-paths [IGNORE_PATHS ...]] [--extensions [EXTENSIONS ...]] [--args ...] function [paths ...] Watch one or more directories and execute a python function on changes. Note: only changes to python files will prompt the function to be restarted, use `--extensions` to watch more file types. positional arguments: function Path to python function to execute. paths Filesystem paths to watch, defaults to current directory. options: -h, --help show this help message and exit --verbosity [VERBOSITY] 0, 1 (default) or 2 --ignore-paths [IGNORE_PATHS ...] Specify paths to directories to ignore their updates --extensions [EXTENSIONS ...] Extra file extensions to watch --args ..., -a ... Arguments for argv inside executed function","title":"CLI"},{"location":"cli/#help","text":"Run watchfiles --help for more options. watchfiles --help usage: watchfiles [-h] [--verbosity [VERBOSITY]] [--ignore-paths [IGNORE_PATHS ...]] [--extensions [EXTENSIONS ...]] [--args ...] function [paths ...] Watch one or more directories and execute a python function on changes. Note: only changes to python files will prompt the function to be restarted, use `--extensions` to watch more file types. positional arguments: function Path to python function to execute. paths Filesystem paths to watch, defaults to current directory. options: -h, --help show this help message and exit --verbosity [VERBOSITY] 0, 1 (default) or 2 --ignore-paths [IGNORE_PATHS ...] Specify paths to directories to ignore their updates --extensions [EXTENSIONS ...] Extra file extensions to watch --args ..., -a ... Arguments for argv inside executed function","title":"Help"},{"location":"migrating/","text":"This package was significantly written and renamed from watchgod to watchfiles , these docs refer to the new watchfiles package. The main reason for this change was to avoid confusion with the similarly named \"watchdog\" package, see #102 for more details. The most significant code change was to switch from file scanning/polling to OS file system notifications using the Notify rust library. This is much more performant than the old approach. As a result, the external interface to the library has been changed somewhat. The main methods: watch awatch run_process arun_process All remain, the following changes affect them all: watcher_cls is removed and replaced by watch_filter which should be a simple callable, see filter docs all these methods allow multiple paths to be watched, as result, the target argument to run_process & arun_process is now keyword-only the other optional keyword arguments have changed somewhat, mostly as a result of cleanup, all public methods are now thoroughly documented The old watchgod package remains \u00b6 The old watchgod pypi package remains, I'll add a notice about the new package name, but otherwise It'll continue to work (in future, it might get deprecation warnings). Documentation is available in the old README .","title":"Migration from watchgod"},{"location":"migrating/#the-old-watchgod-package-remains","text":"The old watchgod pypi package remains, I'll add a notice about the new package name, but otherwise It'll continue to work (in future, it might get deprecation warnings). Documentation is available in the old README .","title":"The old watchgod package remains"},{"location":"api/filters/","text":"All classes described here are designed to be used for the watch_filter argument to the watch function and similar. This argument requires a simple callable which takes two arguments (the Change type and the path as a string) and returns a boolean indicating if the change should be included ( True ) or ignored ( False ). As shown below in Custom Filters , you can either a BaseFilter subclass instance or your own callable. BaseFilter \u00b6 Useful base class for creating filters. BaseFilter should be inherited and configured, rather than used directly. The class supports ignoring files in 3 ways: ignore_dirs class-attribute \u00b6 ignore_dirs : Sequence [ str ] = () Full names of directories to ignore, an obvious example would be .git . ignore_entity_patterns class-attribute \u00b6 ignore_entity_patterns : Sequence [ str ] = () Patterns of files or directories to ignore, these are compiled into regexes. \"entity\" here refers to the specific file or directory - basically the result of path.split(os.sep)[-1] , an obvious example would be r'\\.py[cod]$' . ignore_paths class-attribute \u00b6 ignore_paths : Sequence [ Union [ str , Path ]] = () Full paths to ignore, e.g. /home/users/.cache or C:\\Users\\user\\.cache . __call__ \u00b6 __call__ ( change : 'Change' , path : str ) -> bool Instances of BaseFilter subclasses can be used as callables. Parameters: Name Type Description Default change 'Change' The type of change that occurred, see Change . required path str the raw path of the file or directory that changed. required Returns: Type Description bool True if the file should be included in changes, False if it should be ignored. DefaultFilter \u00b6 DefaultFilter ( * , ignore_dirs : Optional [ Sequence [ str ]] = None , ignore_entity_patterns : Optional [ Sequence [ str ]] = None , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None ) -> None Bases: BaseFilter The default filter, which ignores files and directories that you might commonly want to ignore. Parameters: Name Type Description Default ignore_dirs Optional [ Sequence [ str ]] if not None , overrides the ignore_dirs value set on the class. None ignore_entity_patterns Optional [ Sequence [ str ]] if not None , overrides the ignore_entity_patterns value set on the class. None ignore_paths Optional [ Sequence [ Union [ str , Path ]]] if not None , overrides the ignore_paths value set on the class. None ignore_dirs class-attribute \u00b6 ignore_dirs : Sequence [ str ] = ( \"__pycache__\" , \".git\" , \".hg\" , \".svn\" , \".tox\" , \".venv\" , \"site-packages\" , \".idea\" , \"node_modules\" , ) Directory names to ignore. ignore_entity_patterns class-attribute \u00b6 ignore_entity_patterns : Sequence [ str ] = ( \" \\\\ .py[cod]$\" , \" \\\\ .___jb_...___$\" , \" \\\\ .sw.$\" , \"~$\" , \"^ \\\\ . \\\\ #\" , \"^ \\\\ .DS_Store$\" , \"^flycheck_\" , ) File/Directory name patterns to ignore. PythonFilter \u00b6 PythonFilter ( * , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None , extra_extensions : Sequence [ str ] = () ) -> None Bases: DefaultFilter A filter for Python files, since this class inherits from DefaultFilter it will ignore files and directories that you might commonly want to ignore as well as filtering out all changes except in Python files (files with extensions ('.py', '.pyx', '.pyd') ). Parameters: Name Type Description Default ignore_paths Optional [ Sequence [ Union [ str , Path ]]] The paths to ignore, see BaseFilter . None extra_extensions Sequence [ str ] extra extensions to ignore. () ignore_paths and extra_extensions can be passed as arguments partly to support CLI usage where --ignore-paths and --extensions can be passed as arguments. Custom Filters \u00b6 Here's an example of a custom filter which extends DefaultFilter to only notice changes to common web files: from watchfiles import Change , DefaultFilter , watch class WebFilter ( DefaultFilter ): allowed_extensions = '.html' , '.css' , '.js' def __call__ ( self , change : Change , path : str ) -> bool : return ( super () . __call__ ( change , path ) and path . endswith ( self . allowed_extensions ) ) for changes in watch ( 'my/web/project' , watch_filter = WebFilter ()): print ( changes ) Here's an example of a customer filter which is a simple callable that ignores changes unless they represent a new file being created: from watchfiles import Change , watch def only_added ( change : Change , path : str ) -> bool : return change == Change . added for changes in watch ( 'my/project' , watch_filter = only_added ): print ( changes ) For more details, see filters.py .","title":"Filters"},{"location":"api/filters/#watchfiles.BaseFilter","text":"Useful base class for creating filters. BaseFilter should be inherited and configured, rather than used directly. The class supports ignoring files in 3 ways:","title":"BaseFilter"},{"location":"api/filters/#watchfiles.filters.BaseFilter.ignore_dirs","text":"ignore_dirs : Sequence [ str ] = () Full names of directories to ignore, an obvious example would be .git .","title":"ignore_dirs"},{"location":"api/filters/#watchfiles.filters.BaseFilter.ignore_entity_patterns","text":"ignore_entity_patterns : Sequence [ str ] = () Patterns of files or directories to ignore, these are compiled into regexes. \"entity\" here refers to the specific file or directory - basically the result of path.split(os.sep)[-1] , an obvious example would be r'\\.py[cod]$' .","title":"ignore_entity_patterns"},{"location":"api/filters/#watchfiles.filters.BaseFilter.ignore_paths","text":"ignore_paths : Sequence [ Union [ str , Path ]] = () Full paths to ignore, e.g. /home/users/.cache or C:\\Users\\user\\.cache .","title":"ignore_paths"},{"location":"api/filters/#watchfiles.filters.BaseFilter.__call__","text":"__call__ ( change : 'Change' , path : str ) -> bool Instances of BaseFilter subclasses can be used as callables. Parameters: Name Type Description Default change 'Change' The type of change that occurred, see Change . required path str the raw path of the file or directory that changed. required Returns: Type Description bool True if the file should be included in changes, False if it should be ignored.","title":"__call__()"},{"location":"api/filters/#watchfiles.DefaultFilter","text":"DefaultFilter ( * , ignore_dirs : Optional [ Sequence [ str ]] = None , ignore_entity_patterns : Optional [ Sequence [ str ]] = None , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None ) -> None Bases: BaseFilter The default filter, which ignores files and directories that you might commonly want to ignore. Parameters: Name Type Description Default ignore_dirs Optional [ Sequence [ str ]] if not None , overrides the ignore_dirs value set on the class. None ignore_entity_patterns Optional [ Sequence [ str ]] if not None , overrides the ignore_entity_patterns value set on the class. None ignore_paths Optional [ Sequence [ Union [ str , Path ]]] if not None , overrides the ignore_paths value set on the class. None","title":"DefaultFilter"},{"location":"api/filters/#watchfiles.filters.DefaultFilter.ignore_dirs","text":"ignore_dirs : Sequence [ str ] = ( \"__pycache__\" , \".git\" , \".hg\" , \".svn\" , \".tox\" , \".venv\" , \"site-packages\" , \".idea\" , \"node_modules\" , ) Directory names to ignore.","title":"ignore_dirs"},{"location":"api/filters/#watchfiles.filters.DefaultFilter.ignore_entity_patterns","text":"ignore_entity_patterns : Sequence [ str ] = ( \" \\\\ .py[cod]$\" , \" \\\\ .___jb_...___$\" , \" \\\\ .sw.$\" , \"~$\" , \"^ \\\\ . \\\\ #\" , \"^ \\\\ .DS_Store$\" , \"^flycheck_\" , ) File/Directory name patterns to ignore.","title":"ignore_entity_patterns"},{"location":"api/filters/#watchfiles.PythonFilter","text":"PythonFilter ( * , ignore_paths : Optional [ Sequence [ Union [ str , Path ]] ] = None , extra_extensions : Sequence [ str ] = () ) -> None Bases: DefaultFilter A filter for Python files, since this class inherits from DefaultFilter it will ignore files and directories that you might commonly want to ignore as well as filtering out all changes except in Python files (files with extensions ('.py', '.pyx', '.pyd') ). Parameters: Name Type Description Default ignore_paths Optional [ Sequence [ Union [ str , Path ]]] The paths to ignore, see BaseFilter . None extra_extensions Sequence [ str ] extra extensions to ignore. () ignore_paths and extra_extensions can be passed as arguments partly to support CLI usage where --ignore-paths and --extensions can be passed as arguments.","title":"PythonFilter"},{"location":"api/filters/#custom-filters","text":"Here's an example of a custom filter which extends DefaultFilter to only notice changes to common web files: from watchfiles import Change , DefaultFilter , watch class WebFilter ( DefaultFilter ): allowed_extensions = '.html' , '.css' , '.js' def __call__ ( self , change : Change , path : str ) -> bool : return ( super () . __call__ ( change , path ) and path . endswith ( self . allowed_extensions ) ) for changes in watch ( 'my/web/project' , watch_filter = WebFilter ()): print ( changes ) Here's an example of a customer filter which is a simple callable that ignores changes unless they represent a new file being created: from watchfiles import Change , watch def only_added ( change : Change , path : str ) -> bool : return change == Change . added for changes in watch ( 'my/project' , watch_filter = only_added ): print ( changes ) For more details, see filters.py .","title":"Custom Filters"},{"location":"api/run_process/","text":"run_process \u00b6 run_process ( * paths : Union [ Path , str ], target : \"AnyCallable\" , args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , callback : Optional [ Callable [[ Set [ FileChange ]], None ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = PythonFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False ) -> int Run a function in a subprocess using multiprocessing.Process (technically multiprocessing.get_context('spawn').Process to avoid forking and improve code reload), restart it whenever files change in path. Internally, run_process uses watch with raise_interrupt=False so the function exits cleanly upon Ctrl+C . Parameters: Name Type Description Default *paths Union [ Path , str ] matches the same argument of watch () target 'AnyCallable' function to run required args Tuple [ Any , ...] arguments to pass to target () kwargs Optional [ Dict [ str , Any ]] keyword arguments to pass to target None callback Optional [ Callable [[ Set [ FileChange ]], None]] function to call on each reload, the function should accept a set of changes as the sole argument None watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch , except an instance of PythonFilter is used by default so only python files are watched. PythonFilter() debounce int matches the same argument of watch 1600 step int matches the same argument of watch 50 debug bool matches the same argument of watch False Returns: Type Description int number of times the function was reloaded. Example of run_process usage from watchfiles import run_process def callback ( changes ): print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 ), callback = callback ) As well as using a callback function, changes can be accessed from within the target function, using the WATCHFILES_CHANGES environment variable. Example of run_process accessing changes from watchfiles import run_process def foobar ( a , b , c ): # changes will be an empty list \"[]\" the first time the function is called changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) print ( 'foobar called due to changes:' , changes ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 )) arun_process async \u00b6 arun_process ( * paths : Union [ Path , str ], target : \"AnyCallable\" , args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , callback : Optional [ Callable [[ Set [ FileChange ]], Any ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = PythonFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False ) -> int Async equivalent of run_process , all arguments match those of run_process except callback which can be a coroutine. Starting and stopping the process and watching for changes is done in a separate thread. As with run_process , internally arun_process uses awatch with raise_interrupt=False so the function exits cleanly upon Ctrl+C . Example of arun_process usage import asyncio from watchfiles import arun_process async def callback ( changes ): await asyncio . sleep ( 0.1 ) print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) async def main (): await arun_process ( '.' , target = foobar , args = ( 1 , 2 ), callback = callback ) if __name__ == '__main__' : asyncio . run ( main ())","title":"Run process"},{"location":"api/run_process/#watchfiles.run_process","text":"run_process ( * paths : Union [ Path , str ], target : \"AnyCallable\" , args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , callback : Optional [ Callable [[ Set [ FileChange ]], None ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = PythonFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False ) -> int Run a function in a subprocess using multiprocessing.Process (technically multiprocessing.get_context('spawn').Process to avoid forking and improve code reload), restart it whenever files change in path. Internally, run_process uses watch with raise_interrupt=False so the function exits cleanly upon Ctrl+C . Parameters: Name Type Description Default *paths Union [ Path , str ] matches the same argument of watch () target 'AnyCallable' function to run required args Tuple [ Any , ...] arguments to pass to target () kwargs Optional [ Dict [ str , Any ]] keyword arguments to pass to target None callback Optional [ Callable [[ Set [ FileChange ]], None]] function to call on each reload, the function should accept a set of changes as the sole argument None watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch , except an instance of PythonFilter is used by default so only python files are watched. PythonFilter() debounce int matches the same argument of watch 1600 step int matches the same argument of watch 50 debug bool matches the same argument of watch False Returns: Type Description int number of times the function was reloaded. Example of run_process usage from watchfiles import run_process def callback ( changes ): print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 ), callback = callback ) As well as using a callback function, changes can be accessed from within the target function, using the WATCHFILES_CHANGES environment variable. Example of run_process accessing changes from watchfiles import run_process def foobar ( a , b , c ): # changes will be an empty list \"[]\" the first time the function is called changes = os . getenv ( 'WATCHFILES_CHANGES' ) changes = json . loads ( changes ) print ( 'foobar called due to changes:' , changes ) if __name__ == '__main__' : run_process ( './path/to/dir' , target = foobar , args = ( 1 , 2 , 3 ))","title":"run_process()"},{"location":"api/run_process/#watchfiles.arun_process","text":"arun_process ( * paths : Union [ Path , str ], target : \"AnyCallable\" , args : Tuple [ Any , ... ] = (), kwargs : Optional [ Dict [ str , Any ]] = None , callback : Optional [ Callable [[ Set [ FileChange ]], Any ] ] = None , watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = PythonFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False ) -> int Async equivalent of run_process , all arguments match those of run_process except callback which can be a coroutine. Starting and stopping the process and watching for changes is done in a separate thread. As with run_process , internally arun_process uses awatch with raise_interrupt=False so the function exits cleanly upon Ctrl+C . Example of arun_process usage import asyncio from watchfiles import arun_process async def callback ( changes ): await asyncio . sleep ( 0.1 ) print ( 'changes detected:' , changes ) def foobar ( a , b ): print ( 'foobar called with:' , a , b ) async def main (): await arun_process ( '.' , target = foobar , args = ( 1 , 2 ), callback = callback ) if __name__ == '__main__' : asyncio . run ( main ())","title":"arun_process()"},{"location":"api/rust_backend/","text":"The _rust_notify.pyi file defines the interface to rust: _rust_notify.pyi from typing import List , Optional , Protocol , Set , Tuple __all__ = 'RustNotify' , 'WatchfilesRustInternalError' class AbstractEvent ( Protocol ): def is_set ( self ) -> bool : ... class RustNotify : \"\"\" Interface to the Rust [notify](https://crates.io/crates/notify) crate which does the heavy lifting of watching for file changes and grouping them into a single event. \"\"\" def __init__ ( self , watch_paths : List [ str ], debug : bool ) -> None : \"\"\" Create a new RustNotify instance and start a thread to watch for changes. `FileNotFoundError` is raised if one of the directories does not exist. Args: watch_paths: file system paths to watch for changes debug: if true, print details about all events to stderr \"\"\" def watch ( self , debounce_ms : int , step_ms : int , cancel_event : Optional [ AbstractEvent ], ) -> Optional [ Set [ Tuple [ int , str ]]]: \"\"\" Watch for changes and return a set of `(event_type, path)` tuples. This method will wait indefinitely for changes, but once a change is detected, it will group changes and return in no more than `debounce_ms` milliseconds. The GIL is released during a `step_ms` sleep on each iteration to avoid blocking other threads. Args: debounce_ms: maximum time in milliseconds to group changes over before returning. step_ms: time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. cancel_event: event to check on every iteration to see if this function should return early. Returns: A set of `(event_type, path)` tuples, the event types are ints which match [`Change`][watchfiles.Change]. \"\"\" class WatchfilesRustInternalError ( RuntimeError ): \"\"\" Raised when RustNotify encounters an unknown error. If you get this a lot, please file a bug in github. \"\"\" The rust backend can be accessed directly as follows: Rust backend example from watchfiles._rust_notify import RustNotify r = RustNotify ([ 'first/path' , 'second/path' ], False ) changes = r . watch ( 1_600 , 50 , None ) print ( changes )","title":"Rust backend"},{"location":"api/watch/","text":"watch \u00b6 watch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ \"Change\" , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False , raise_interrupt : bool = True ) -> Generator [ Set [ FileChange ], None , None ] Watch one or more directories and yield a set of changes whenever files change in those directories (or subdirectories). Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem directories to watch () watch_filter Optional [ Callable [['Change', str ], bool ]] callable used to filter out changes which are not important, you can either use a raw callable or a BaseFilter instance, defaults to an instance of DefaultFilter . To keep all changes, use None . DefaultFilter() debounce int maximum time in milliseconds to group changes over before yielding them. 1600 step int time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. 50 debug bool whether to print information about all filesystem changes in rust to stdout. False raise_interrupt bool whether to re-raise KeyboardInterrupt s, or suppress the error and just stop iterating. True Yields: Type Description Generator [ Set [ FileChange ], None, None] The generator yields sets of FileChange s. Example of watch usage from watchfiles import watch for changes in watch ( './first/dir' , './second/dir' , raise_interrupt = False ): print ( changes ) awatch async \u00b6 awatch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , stop_event : Optional [ \"AnyEvent\" ] = None , debug : bool = False , raise_interrupt : bool = True ) -> AsyncGenerator [ Set [ FileChange ], None ] Asynchronous equivalent of watch using threads to wait for changes. Arguments match those of watch except stop_event . All async methods use anyio to run the event loop. Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem directories to watch () stop_event Optional ['AnyEvent'] None watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch . DefaultFilter() debounce int matches the same argument of watch . 1600 step int matches the same argument of watch . 50 debug bool matches the same argument of watch . False stop_event Optional ['AnyEvent'] anyio.Event which can be used to stop iteration, see example below. None raise_interrupt bool matches the same argument of watch . True Yields: Type Description AsyncGenerator [ Set [ FileChange ], None] The generator yields sets of FileChange s. Example of awatch usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( './first/dir' , './second/dir' ): print ( changes ) asyncio . run ( main ()) Example of awatch usage with a stop event import asyncio from watchfiles import awatch async def main (): stop_event = asyncio . Event () async def stop_soon (): await asyncio . sleep ( 3 ) stop_event . set () stop_soon_task = asyncio . create_task ( stop_soon ()) async for changes in awatch ( '/path/to/dir' , stop_event = stop_event ): print ( changes ) # cleanup by awaiting the (now complete) stop_soon_task await stop_soon_task asyncio . run ( main ()) Change \u00b6 Bases: IntEnum Enum representing the type of change that occurred. added class-attribute \u00b6 added = 1 A new file was added. deleted class-attribute \u00b6 deleted = 3 A file was deleted. modified class-attribute \u00b6 modified = 2 A file was modified, can be either a metadata or data change. FileChange module-attribute \u00b6 FileChange = Tuple [ Change , str ] A tuple representing a file change, first element is a Change member, second is the path of the file or directory that changed.","title":"Watch"},{"location":"api/watch/#watchfiles.watch","text":"watch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ \"Change\" , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , debug : bool = False , raise_interrupt : bool = True ) -> Generator [ Set [ FileChange ], None , None ] Watch one or more directories and yield a set of changes whenever files change in those directories (or subdirectories). Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem directories to watch () watch_filter Optional [ Callable [['Change', str ], bool ]] callable used to filter out changes which are not important, you can either use a raw callable or a BaseFilter instance, defaults to an instance of DefaultFilter . To keep all changes, use None . DefaultFilter() debounce int maximum time in milliseconds to group changes over before yielding them. 1600 step int time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded. 50 debug bool whether to print information about all filesystem changes in rust to stdout. False raise_interrupt bool whether to re-raise KeyboardInterrupt s, or suppress the error and just stop iterating. True Yields: Type Description Generator [ Set [ FileChange ], None, None] The generator yields sets of FileChange s. Example of watch usage from watchfiles import watch for changes in watch ( './first/dir' , './second/dir' , raise_interrupt = False ): print ( changes )","title":"watch()"},{"location":"api/watch/#watchfiles.awatch","text":"awatch ( * paths : Union [ Path , str ], watch_filter : Optional [ Callable [[ Change , str ], bool ] ] = DefaultFilter (), debounce : int = 1600 , step : int = 50 , stop_event : Optional [ \"AnyEvent\" ] = None , debug : bool = False , raise_interrupt : bool = True ) -> AsyncGenerator [ Set [ FileChange ], None ] Asynchronous equivalent of watch using threads to wait for changes. Arguments match those of watch except stop_event . All async methods use anyio to run the event loop. Parameters: Name Type Description Default *paths Union [ Path , str ] filesystem directories to watch () stop_event Optional ['AnyEvent'] None watch_filter Optional [ Callable [[ Change , str ], bool ]] matches the same argument of watch . DefaultFilter() debounce int matches the same argument of watch . 1600 step int matches the same argument of watch . 50 debug bool matches the same argument of watch . False stop_event Optional ['AnyEvent'] anyio.Event which can be used to stop iteration, see example below. None raise_interrupt bool matches the same argument of watch . True Yields: Type Description AsyncGenerator [ Set [ FileChange ], None] The generator yields sets of FileChange s. Example of awatch usage import asyncio from watchfiles import awatch async def main (): async for changes in awatch ( './first/dir' , './second/dir' ): print ( changes ) asyncio . run ( main ()) Example of awatch usage with a stop event import asyncio from watchfiles import awatch async def main (): stop_event = asyncio . Event () async def stop_soon (): await asyncio . sleep ( 3 ) stop_event . set () stop_soon_task = asyncio . create_task ( stop_soon ()) async for changes in awatch ( '/path/to/dir' , stop_event = stop_event ): print ( changes ) # cleanup by awaiting the (now complete) stop_soon_task await stop_soon_task asyncio . run ( main ())","title":"awatch()"},{"location":"api/watch/#watchfiles.Change","text":"Bases: IntEnum Enum representing the type of change that occurred.","title":"Change"},{"location":"api/watch/#watchfiles.main.Change.added","text":"added = 1 A new file was added.","title":"added"},{"location":"api/watch/#watchfiles.main.Change.deleted","text":"deleted = 3 A file was deleted.","title":"deleted"},{"location":"api/watch/#watchfiles.main.Change.modified","text":"modified = 2 A file was modified, can be either a metadata or data change.","title":"modified"},{"location":"api/watch/#watchfiles.main.FileChange","text":"FileChange = Tuple [ Change , str ] A tuple representing a file change, first element is a Change member, second is the path of the file or directory that changed.","title":"FileChange"}]}