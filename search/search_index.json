{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"watchfiles","text":"<p>Documentation for version: v0.22.0.</p> <p>Simple, modern and high performance file watching and code reload in python.</p> <p>Underlying file system notifications are handled by the Notify rust library.</p> <p>This package was previously named \"watchgod\", see Migrating from watchgod for more information.</p>"},{"location":"#usage","title":"Usage","text":"<p>Here are some examples of what watchfiles can do:</p> <p>watch Usage<pre><code>from watchfiles import watch\n\nfor changes in watch('./path/to/dir'):\n    print(changes)\n</code></pre> See <code>watch</code> docs for more details.</p> <p><code>watch</code> (and all other methods) can watch either files or directories and can watch more than one path with a single instance.</p> <p>awatch Usage<pre><code>import asyncio\nfrom watchfiles import awatch\n\nasync def main():\n    async for changes in awatch('/path/to/dir'):\n        print(changes)\n\nasyncio.run(main())\n</code></pre> See <code>awatch</code> docs for more details.</p> <p>run_process Usage<pre><code>from watchfiles import run_process\n\ndef foobar(a, b, c):\n    ...\n\nif __name__ == '__main__':\n    run_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n</code></pre> See <code>run_process</code> docs for more details.</p> <p>arun_process Usage<pre><code>import asyncio\nfrom watchfiles import arun_process\n\ndef foobar(a, b, c):\n    ...\n\nasync def main():\n    await arun_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> See <code>arun_process</code> docs for more details.</p>"},{"location":"#installation","title":"Installation","text":"<p>watchfiles requires Python 3.7 to Python 3.10.</p>"},{"location":"#from-pypi","title":"From PyPI","text":"<p>Using <code>pip</code>:</p> <pre><code>pip install watchfiles\n</code></pre> <p>Binaries are available for:</p> <ul> <li>Linux: <code>x86_64</code>, <code>aarch64</code>, <code>i686</code>, <code>armv7l</code>, <code>musl-x86_64</code> &amp; <code>musl-aarch64</code></li> <li>MacOS: <code>x86_64</code> &amp; <code>arm64</code> (except python 3.7)</li> <li>Windows: <code>amd64</code> &amp; <code>win32</code></li> </ul>"},{"location":"#from-conda-forge","title":"From conda-forge","text":"<p>Using <code>conda</code> or <code>mamba</code>:</p> <pre><code>mamba install -c conda-forge watchfiles\n</code></pre> <p>Binaries are available for:</p> <ul> <li>Linux: <code>x86_64</code></li> <li>MacOS: <code>x86_64</code> &amp; <code>arm64</code> (except python 3.7)</li> <li>Windows: <code>amd64</code></li> </ul>"},{"location":"#from-source","title":"From source","text":"<p>You can also install from source which requires Rust stable to be installed.</p>"},{"location":"#how-watchfiles-works","title":"How Watchfiles Works","text":"<p>watchfiles is based on the Notify rust library.</p> <p>All the hard work of integrating with the OS's file system events notifications and falling back to polling is palmed off onto the rust library.</p> <p>\"Debouncing\" changes - e.g. grouping changes into batches rather than firing a yield/reload for each file changed is managed in rust.</p> <p>The rust code takes care of creating a new thread to watch for file changes so in the case of the synchronous methods (<code>watch</code> and <code>run_process</code>) no threading logic is required in python. When using the asynchronous methods (<code>awatch</code> and <code>arun_process</code>) <code>anyio.to_thread.run_sync</code> is used to wait for changes in a thread.</p>"},{"location":"cli/","title":"CLI","text":"<p>watchfiles comes with a CLI for running and reloading code, the CLI uses watchfiles.run_process to run the code and like <code>run_process</code> can either run a python function or a shell-like command.</p> <p>The CLI can be used either via <code>watchfiles ...</code> or <code>python -m watchfiles ...</code>.</p>"},{"location":"cli/#running-and-restarting-a-python-function","title":"Running and restarting a python function","text":"<p>Let's say you have <code>foobar.py</code> (in this case a very simple web server using aiohttp) which gets details about recent file changes from the <code>WATCHFILES_CHANGES</code> environment variable (see <code>run_process</code> docs) and returns them as JSON.</p> foobar.py<pre><code>import os, json\nfrom aiohttp import web\n\nasync def handle(request):\n    # get the most recent file changes and return them\n    changes = os.getenv('WATCHFILES_CHANGES')\n    changes = json.loads(changes)\n    return web.json_response(dict(changes=changes))\n\napp = web.Application()\napp.router.add_get('/', handle)\n\ndef main():\n    web.run_app(app, port=8000)\n</code></pre> <p>You could run this and reload it when any file in the current directory changes with:</p> Running a python function<pre><code>watchfiles foobar.main\n</code></pre>"},{"location":"cli/#running-and-restarting-a-command","title":"Running and restarting a command","text":"<p>Let's say you want to re-run failing tests whenever files change. You could do this with watchfiles using</p> Running a command<pre><code>watchfiles 'pytest --lf'\n</code></pre> <p>(pytest's <code>--lf</code> option is a shortcut for <code>--last-failed</code>, see pytest docs)</p> <p>By default the CLI will watch the current directory and all subdirectories, but the directory/directories watched can be changed.</p> <p>In this example, we might want to watch only the <code>src</code> and <code>tests</code> directories, and only react to changes in python files:</p> Watching custom directories and files<pre><code>watchfiles --filter python 'pytest --lf' src tests\n</code></pre>"},{"location":"cli/#help","title":"Help","text":"<p>Run <code>watchfiles --help</code> for more options.</p> watchfiles --help<pre><code>usage: watchfiles [-h] [--ignore-paths [IGNORE_PATHS]]\n                  [--target-type [{command,function,auto}]]\n                  [--filter [FILTER]] [--args [ARGS]] [--verbose]\n                  [--non-recursive] [--verbosity [{warning,info,debug}]]\n                  [--sigint-timeout [SIGINT_TIMEOUT]]\n                  [--grace-period [GRACE_PERIOD]]\n                  [--sigkill-timeout [SIGKILL_TIMEOUT]]\n                  [--ignore-permission-denied] [--version]\n                  target [paths ...]\n\nWatch one or more directories and execute either a shell command or a python function on file changes.\n\nExample of watching the current directory and calling a python function:\n\n    watchfiles foobar.main\n\nExample of watching python files in two local directories and calling a shell command:\n\n    watchfiles --filter python 'pytest --lf' src tests\n\nSee https://watchfiles.helpmanual.io/cli/ for more information.\n\npositional arguments:\n  target                Command or dotted function path to run\n  paths                 Filesystem paths to watch, defaults to current directory\n\noptions:\n  -h, --help            show this help message and exit\n  --ignore-paths [IGNORE_PATHS]\n                        Specify directories to ignore, to ignore multiple paths use a comma as separator, e.g. \"env\" or \"env,node_modules\"\n  --target-type [{command,function,auto}]\n                        Whether the target should be intercepted as a shell command or a python function, defaults to \"auto\" which infers the target type from the target string\n  --filter [FILTER]     Which files to watch, defaults to \"default\" which uses the \"DefaultFilter\", \"python\" uses the \"PythonFilter\", \"all\" uses no filter, any other value is interpreted as a python function/class path which is imported\n  --args [ARGS]         Arguments to set on sys.argv before calling target function, used only if the target is a function\n  --verbose             Set log level to \"debug\", wins over `--verbosity`\n  --non-recursive       Do not watch for changes in sub-directories recursively\n  --verbosity [{warning,info,debug}]\n                        Log level, defaults to \"info\"\n  --sigint-timeout [SIGINT_TIMEOUT]\n                        How long to wait for the sigint timeout before sending sigkill.\n  --grace-period [GRACE_PERIOD]\n                        Number of seconds after the process is started before watching for changes.\n  --sigkill-timeout [SIGKILL_TIMEOUT]\n                        How long to wait for the sigkill timeout before issuing a timeout exception.\n  --ignore-permission-denied\n                        Ignore permission denied errors while watching files and directories.\n  --version, -V         show program's version number and exit\n</code></pre>"},{"location":"migrating/","title":"Migration from watchgod","text":"<p>This package was significantly rewritten and renamed from <code>watchgod</code> to <code>watchfiles</code>, these docs refer to the new <code>watchfiles</code> package.</p> <p>The main reason for this change was to avoid confusion with the similarly named \"watchdog\" package, see #102 for more details.</p> <p>The most significant code change was to switch from file scanning/polling to OS file system notifications using the Notify rust library. This is much more performant than the old approach.</p> <p>As a result, the external interface to the library has been changed somewhat.</p> <p>The main methods:</p> <ul> <li><code>watch</code></li> <li><code>awatch</code></li> <li><code>run_process</code></li> <li><code>arun_process</code></li> </ul> <p>All remain, the following changes affect them all:</p> <ul> <li><code>watcher_cls</code> is removed and replaced by <code>watch_filter</code> which should be a simple callable,   see filter docs</li> <li>all these methods allow multiple paths to be watched, as result, the <code>target</code> argument to <code>run_process</code>   &amp; <code>arun_process</code> is now keyword-only</li> <li>the other optional keyword arguments have changed somewhat, mostly as a result of cleanup, all public   methods are now thoroughly documented</li> </ul>"},{"location":"migrating/#the-old-watchgod-package-remains","title":"The old <code>watchgod</code> package remains","text":"<p>The old <code>watchgod</code> pypi package remains, I'll add a notice about the new package name, but otherwise It'll continue to work (in future, it might get deprecation warnings).</p> <p>Documentation is available in the old README.</p>"},{"location":"api/filters/","title":"Filters","text":"<p>All classes described here are designed to be used for the <code>watch_filter</code> argument to the <code>watch</code> function and similar.</p> <p>This argument requires a simple callable which takes two arguments (the <code>Change</code> type and the path as a string) and returns a boolean indicating if the change should be included (<code>True</code>) or ignored (<code>False</code>).</p> <p>As shown below in Custom Filters, you can either a <code>BaseFilter</code> subclass instance or your own callable.</p> <p>Useful base class for creating filters. <code>BaseFilter</code> should be inherited and configured, rather than used directly.</p> <p>The class supports ignoring files in 3 ways:</p> Source code in <code>watchfiles/filters.py</code> <pre><code>class BaseFilter:\n    \"\"\"\n    Useful base class for creating filters. `BaseFilter` should be inherited and configured, rather than used\n    directly.\n\n    The class supports ignoring files in 3 ways:\n    \"\"\"\n\n    __slots__ = '_ignore_dirs', '_ignore_entity_regexes', '_ignore_paths'\n    ignore_dirs: Sequence[str] = ()\n    \"\"\"Full names of directories to ignore, an obvious example would be `.git`.\"\"\"\n    ignore_entity_patterns: Sequence[str] = ()\n    \"\"\"\n    Patterns of files or directories to ignore, these are compiled into regexes.\n\n    \"entity\" here refers to the specific file or directory - basically the result of `path.split(os.sep)[-1]`,\n    an obvious example would be `r'\\\\.py[cod]$'`.\n    \"\"\"\n    ignore_paths: Sequence[Union[str, Path]] = ()\n    \"\"\"\n    Full paths to ignore, e.g. `/home/users/.cache` or `C:\\\\Users\\\\user\\\\.cache`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._ignore_dirs = set(self.ignore_dirs)\n        self._ignore_entity_regexes = tuple(re.compile(r) for r in self.ignore_entity_patterns)\n        self._ignore_paths = tuple(map(str, self.ignore_paths))\n\n    def __call__(self, change: 'Change', path: str) -&gt; bool:\n        \"\"\"\n        Instances of `BaseFilter` subclasses can be used as callables.\n        Args:\n            change: The type of change that occurred, see [`Change`][watchfiles.Change].\n            path: the raw path of the file or directory that changed.\n\n        Returns:\n            True if the file should be included in changes, False if it should be ignored.\n        \"\"\"\n        parts = path.lstrip(os.sep).split(os.sep)\n        if any(p in self._ignore_dirs for p in parts):\n            return False\n\n        entity_name = parts[-1]\n        if any(r.search(entity_name) for r in self._ignore_entity_regexes):\n            return False\n        elif self._ignore_paths and path.startswith(self._ignore_paths):\n            return False\n        else:\n            return True\n\n    def __repr__(self) -&gt; str:\n        args = ', '.join(f'{k}={getattr(self, k, None)!r}' for k in self.__slots__)\n        return f'{self.__class__.__name__}({args})'\n</code></pre> <p>             Bases: <code>BaseFilter</code></p> <p>The default filter, which ignores files and directories that you might commonly want to ignore.</p> Source code in <code>watchfiles/filters.py</code> <pre><code>class DefaultFilter(BaseFilter):\n    \"\"\"\n    The default filter, which ignores files and directories that you might commonly want to ignore.\n    \"\"\"\n\n    ignore_dirs: Sequence[str] = (\n        '__pycache__',\n        '.git',\n        '.hg',\n        '.svn',\n        '.tox',\n        '.venv',\n        'site-packages',\n        '.idea',\n        'node_modules',\n        '.mypy_cache',\n        '.pytest_cache',\n        '.hypothesis',\n    )\n    \"\"\"Directory names to ignore.\"\"\"\n\n    ignore_entity_patterns: Sequence[str] = (\n        r'\\.py[cod]$',\n        r'\\.___jb_...___$',\n        r'\\.sw.$',\n        '~$',\n        r'^\\.\\#',\n        r'^\\.DS_Store$',\n        r'^flycheck_',\n    )\n    \"\"\"File/Directory name patterns to ignore.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        ignore_dirs: Optional[Sequence[str]] = None,\n        ignore_entity_patterns: Optional[Sequence[str]] = None,\n        ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            ignore_dirs: if not `None`, overrides the `ignore_dirs` value set on the class.\n            ignore_entity_patterns: if not `None`, overrides the `ignore_entity_patterns` value set on the class.\n            ignore_paths: if not `None`, overrides the `ignore_paths` value set on the class.\n        \"\"\"\n        if ignore_dirs is not None:\n            self.ignore_dirs = ignore_dirs\n        if ignore_entity_patterns is not None:\n            self.ignore_entity_patterns = ignore_entity_patterns\n        if ignore_paths is not None:\n            self.ignore_paths = ignore_paths\n\n        super().__init__()\n</code></pre> <p>             Bases: <code>DefaultFilter</code></p> <p>A filter for Python files, since this class inherits from <code>DefaultFilter</code> it will ignore files and directories that you might commonly want to ignore as well as filtering out all changes except in Python files (files with extensions <code>('.py', '.pyx', '.pyd')</code>).</p> Source code in <code>watchfiles/filters.py</code> <pre><code>class PythonFilter(DefaultFilter):\n    \"\"\"\n    A filter for Python files, since this class inherits from [`DefaultFilter`][watchfiles.DefaultFilter]\n    it will ignore files and directories that you might commonly want to ignore as well as filtering out\n    all changes except in Python files (files with extensions `('.py', '.pyx', '.pyd')`).\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n        extra_extensions: Sequence[str] = (),\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            ignore_paths: The paths to ignore, see [`BaseFilter`][watchfiles.BaseFilter].\n            extra_extensions: extra extensions to ignore.\n\n        `ignore_paths` and `extra_extensions` can be passed as arguments partly to support [CLI](../cli.md) usage where\n        `--ignore-paths` and `--extensions` can be passed as arguments.\n        \"\"\"\n        self.extensions = ('.py', '.pyx', '.pyd') + tuple(extra_extensions)\n        super().__init__(ignore_paths=ignore_paths)\n\n    def __call__(self, change: 'Change', path: str) -&gt; bool:\n        return path.endswith(self.extensions) and super().__call__(change, path)\n</code></pre>"},{"location":"api/filters/#watchfiles.BaseFilter.ignore_dirs","title":"<code>ignore_dirs: Sequence[str] = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Full names of directories to ignore, an obvious example would be <code>.git</code>.</p>"},{"location":"api/filters/#watchfiles.BaseFilter.ignore_entity_patterns","title":"<code>ignore_entity_patterns: Sequence[str] = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Patterns of files or directories to ignore, these are compiled into regexes.</p> <p>\"entity\" here refers to the specific file or directory - basically the result of <code>path.split(os.sep)[-1]</code>, an obvious example would be <code>r'\\.py[cod]$'</code>.</p>"},{"location":"api/filters/#watchfiles.BaseFilter.ignore_paths","title":"<code>ignore_paths: Sequence[Union[str, Path]] = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Full paths to ignore, e.g. <code>/home/users/.cache</code> or <code>C:\\Users\\user\\.cache</code>.</p>"},{"location":"api/filters/#watchfiles.BaseFilter.__call__","title":"<code>__call__(change, path)</code>","text":"<p>Instances of <code>BaseFilter</code> subclasses can be used as callables. Args:     change: The type of change that occurred, see <code>Change</code>.     path: the raw path of the file or directory that changed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the file should be included in changes, False if it should be ignored.</p> Source code in <code>watchfiles/filters.py</code> <pre><code>def __call__(self, change: 'Change', path: str) -&gt; bool:\n    \"\"\"\n    Instances of `BaseFilter` subclasses can be used as callables.\n    Args:\n        change: The type of change that occurred, see [`Change`][watchfiles.Change].\n        path: the raw path of the file or directory that changed.\n\n    Returns:\n        True if the file should be included in changes, False if it should be ignored.\n    \"\"\"\n    parts = path.lstrip(os.sep).split(os.sep)\n    if any(p in self._ignore_dirs for p in parts):\n        return False\n\n    entity_name = parts[-1]\n    if any(r.search(entity_name) for r in self._ignore_entity_regexes):\n        return False\n    elif self._ignore_paths and path.startswith(self._ignore_paths):\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/filters/#watchfiles.DefaultFilter.ignore_dirs","title":"<code>ignore_dirs: Sequence[str] = ('__pycache__', '.git', '.hg', '.svn', '.tox', '.venv', 'site-packages', '.idea', 'node_modules', '.mypy_cache', '.pytest_cache', '.hypothesis')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Directory names to ignore.</p>"},{"location":"api/filters/#watchfiles.DefaultFilter.ignore_entity_patterns","title":"<code>ignore_entity_patterns: Sequence[str] = ('\\\\.py[cod]$', '\\\\.___jb_...___$', '\\\\.sw.$', '~$', '^\\\\.\\\\#', '^\\\\.DS_Store$', '^flycheck_')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>File/Directory name patterns to ignore.</p>"},{"location":"api/filters/#watchfiles.DefaultFilter.__init__","title":"<code>__init__(*, ignore_dirs=None, ignore_entity_patterns=None, ignore_paths=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ignore_dirs</code> <code>Optional[Sequence[str]]</code> <p>if not <code>None</code>, overrides the <code>ignore_dirs</code> value set on the class.</p> <code>None</code> <code>ignore_entity_patterns</code> <code>Optional[Sequence[str]]</code> <p>if not <code>None</code>, overrides the <code>ignore_entity_patterns</code> value set on the class.</p> <code>None</code> <code>ignore_paths</code> <code>Optional[Sequence[Union[str, Path]]]</code> <p>if not <code>None</code>, overrides the <code>ignore_paths</code> value set on the class.</p> <code>None</code> Source code in <code>watchfiles/filters.py</code> <pre><code>def __init__(\n    self,\n    *,\n    ignore_dirs: Optional[Sequence[str]] = None,\n    ignore_entity_patterns: Optional[Sequence[str]] = None,\n    ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        ignore_dirs: if not `None`, overrides the `ignore_dirs` value set on the class.\n        ignore_entity_patterns: if not `None`, overrides the `ignore_entity_patterns` value set on the class.\n        ignore_paths: if not `None`, overrides the `ignore_paths` value set on the class.\n    \"\"\"\n    if ignore_dirs is not None:\n        self.ignore_dirs = ignore_dirs\n    if ignore_entity_patterns is not None:\n        self.ignore_entity_patterns = ignore_entity_patterns\n    if ignore_paths is not None:\n        self.ignore_paths = ignore_paths\n\n    super().__init__()\n</code></pre>"},{"location":"api/filters/#watchfiles.PythonFilter.__init__","title":"<code>__init__(*, ignore_paths=None, extra_extensions=())</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ignore_paths</code> <code>Optional[Sequence[Union[str, Path]]]</code> <p>The paths to ignore, see <code>BaseFilter</code>.</p> <code>None</code> <code>extra_extensions</code> <code>Sequence[str]</code> <p>extra extensions to ignore.</p> <code>()</code> <p><code>ignore_paths</code> and <code>extra_extensions</code> can be passed as arguments partly to support CLI usage where <code>--ignore-paths</code> and <code>--extensions</code> can be passed as arguments.</p> Source code in <code>watchfiles/filters.py</code> <pre><code>def __init__(\n    self,\n    *,\n    ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n    extra_extensions: Sequence[str] = (),\n) -&gt; None:\n    \"\"\"\n    Args:\n        ignore_paths: The paths to ignore, see [`BaseFilter`][watchfiles.BaseFilter].\n        extra_extensions: extra extensions to ignore.\n\n    `ignore_paths` and `extra_extensions` can be passed as arguments partly to support [CLI](../cli.md) usage where\n    `--ignore-paths` and `--extensions` can be passed as arguments.\n    \"\"\"\n    self.extensions = ('.py', '.pyx', '.pyd') + tuple(extra_extensions)\n    super().__init__(ignore_paths=ignore_paths)\n</code></pre>"},{"location":"api/filters/#custom-filters","title":"Custom Filters","text":"<p>Here's an example of a custom filter which extends <code>DefaultFilter</code> to only notice changes to common web files:</p> <pre><code>from watchfiles import Change, DefaultFilter, watch\n\n\nclass WebFilter(DefaultFilter):\n    allowed_extensions = '.html', '.css', '.js'\n\n    def __call__(self, change: Change, path: str) -&gt; bool:\n        return (\n            super().__call__(change, path) and\n            path.endswith(self.allowed_extensions)\n        )\n\nfor changes in watch('my/web/project', watch_filter=WebFilter()):\n    print (changes)\n</code></pre> <p>Here's an example of a customer filter which is a simple callable that ignores changes unless they represent a new file being created:</p> <pre><code>from watchfiles import Change, watch\n\ndef only_added(change: Change, path: str) -&gt; bool:\n    return change == Change.added\n\nfor changes in watch('my/project', watch_filter=only_added):\n    print (changes)\n</code></pre> <p>For more details, see <code>filters.py</code>.</p>"},{"location":"api/run_process/","title":"Run process","text":"<p>Run a process and restart it upon file changes.</p> <p><code>run_process</code> can work in two ways:</p> <ul> <li>Using <code>multiprocessing.Process</code> \u2020 to run a python function</li> <li>Or, using <code>subprocess.Popen</code> to run a command</li> </ul> <p>Note</p> <p>\u2020 technically <code>multiprocessing.get_context('spawn').Process</code> to avoid forking and improve code reload/import.</p> <p>Internally, <code>run_process</code> uses <code>watch</code> with <code>raise_interrupt=False</code> so the function exits cleanly upon <code>Ctrl+C</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[Path, str]</code> <p>matches the same argument of <code>watch</code></p> <code>()</code> <code>target</code> <code>Union[str, Callable[..., Any]]</code> <p>function or command to run</p> required <code>args</code> <code>Tuple[Any, ...]</code> <p>arguments to pass to <code>target</code>, only used if <code>target</code> is a function</p> <code>()</code> <code>kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>keyword arguments to pass to <code>target</code>, only used if <code>target</code> is a function</p> <code>None</code> <code>target_type</code> <code>Literal['function', 'command', 'auto']</code> <p>type of target. Can be <code>'function'</code>, <code>'command'</code>, or <code>'auto'</code> in which case <code>detect_target_type</code> is used to determine the type.</p> <code>'auto'</code> <code>callback</code> <code>Optional[Callable[[Set[FileChange]], None]]</code> <p>function to call on each reload, the function should accept a set of changes as the sole argument</p> <code>None</code> <code>watch_filter</code> <code>Optional[Callable[[Change, str], bool]]</code> <p>matches the same argument of <code>watch</code></p> <code>DefaultFilter()</code> <code>grace_period</code> <code>float</code> <p>number of seconds after the process is started before watching for changes</p> <code>0</code> <code>debounce</code> <code>int</code> <p>matches the same argument of <code>watch</code></p> <code>1600</code> <code>step</code> <code>int</code> <p>matches the same argument of <code>watch</code></p> <code>50</code> <code>debug</code> <code>bool</code> <p>matches the same argument of <code>watch</code></p> <code>False</code> <code>sigint_timeout</code> <code>int</code> <p>the number of seconds to wait after sending sigint before sending sigkill</p> <code>5</code> <code>sigkill_timeout</code> <code>int</code> <p>the number of seconds to wait after sending sigkill before raising an exception</p> <code>1</code> <code>recursive</code> <code>bool</code> <p>matches the same argument of <code>watch</code></p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>number of times the function was reloaded.</p> Example of run_process running a function<pre><code>from watchfiles import run_process\n\ndef callback(changes):\n    print('changes detected:', changes)\n\ndef foobar(a, b):\n    print('foobar called with:', a, b)\n\nif __name__ == '__main__':\n    run_process('./path/to/dir', target=foobar, args=(1, 2), callback=callback)\n</code></pre> <p>As well as using a <code>callback</code> function, changes can be accessed from within the target function, using the <code>WATCHFILES_CHANGES</code> environment variable.</p> Example of run_process accessing changes<pre><code>from watchfiles import run_process\n\ndef foobar(a, b, c):\n    # changes will be an empty list \"[]\" the first time the function is called\n    changes = os.getenv('WATCHFILES_CHANGES')\n    changes = json.loads(changes)\n    print('foobar called due to changes:', changes)\n\nif __name__ == '__main__':\n    run_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n</code></pre> <p>Again with the target as <code>command</code>, <code>WATCHFILES_CHANGES</code> can be used to access changes.</p> example.sh<pre><code>echo \"changers: ${WATCHFILES_CHANGES}\"\n</code></pre> Example of run_process running a command<pre><code>from watchfiles import run_process\n\nif __name__ == '__main__':\n    run_process('.', target='./example.sh')\n</code></pre> Source code in <code>watchfiles/run.py</code> <pre><code>def run_process(\n    *paths: Union[Path, str],\n    target: Union[str, Callable[..., Any]],\n    args: Tuple[Any, ...] = (),\n    kwargs: Optional[Dict[str, Any]] = None,\n    target_type: \"Literal['function', 'command', 'auto']\" = 'auto',\n    callback: Optional[Callable[[Set[FileChange]], None]] = None,\n    watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(),\n    grace_period: float = 0,\n    debounce: int = 1_600,\n    step: int = 50,\n    debug: bool = False,\n    sigint_timeout: int = 5,\n    sigkill_timeout: int = 1,\n    recursive: bool = True,\n    ignore_permission_denied: bool = False,\n) -&gt; int:\n    \"\"\"\n    Run a process and restart it upon file changes.\n\n    `run_process` can work in two ways:\n\n    * Using `multiprocessing.Process` \u2020 to run a python function\n    * Or, using `subprocess.Popen` to run a command\n\n    !!! note\n\n        **\u2020** technically `multiprocessing.get_context('spawn').Process` to avoid forking and improve\n        code reload/import.\n\n    Internally, `run_process` uses [`watch`][watchfiles.watch] with `raise_interrupt=False` so the function\n    exits cleanly upon `Ctrl+C`.\n\n    Args:\n        *paths: matches the same argument of [`watch`][watchfiles.watch]\n        target: function or command to run\n        args: arguments to pass to `target`, only used if `target` is a function\n        kwargs: keyword arguments to pass to `target`, only used if `target` is a function\n        target_type: type of target. Can be `'function'`, `'command'`, or `'auto'` in which case\n            [`detect_target_type`][watchfiles.run.detect_target_type] is used to determine the type.\n        callback: function to call on each reload, the function should accept a set of changes as the sole argument\n        watch_filter: matches the same argument of [`watch`][watchfiles.watch]\n        grace_period: number of seconds after the process is started before watching for changes\n        debounce: matches the same argument of [`watch`][watchfiles.watch]\n        step: matches the same argument of [`watch`][watchfiles.watch]\n        debug: matches the same argument of [`watch`][watchfiles.watch]\n        sigint_timeout: the number of seconds to wait after sending sigint before sending sigkill\n        sigkill_timeout: the number of seconds to wait after sending sigkill before raising an exception\n        recursive: matches the same argument of [`watch`][watchfiles.watch]\n\n    Returns:\n        number of times the function was reloaded.\n\n    ```py title=\"Example of run_process running a function\"\n    from watchfiles import run_process\n\n    def callback(changes):\n        print('changes detected:', changes)\n\n    def foobar(a, b):\n        print('foobar called with:', a, b)\n\n    if __name__ == '__main__':\n        run_process('./path/to/dir', target=foobar, args=(1, 2), callback=callback)\n    ```\n\n    As well as using a `callback` function, changes can be accessed from within the target function,\n    using the `WATCHFILES_CHANGES` environment variable.\n\n    ```py title=\"Example of run_process accessing changes\"\n    from watchfiles import run_process\n\n    def foobar(a, b, c):\n        # changes will be an empty list \"[]\" the first time the function is called\n        changes = os.getenv('WATCHFILES_CHANGES')\n        changes = json.loads(changes)\n        print('foobar called due to changes:', changes)\n\n    if __name__ == '__main__':\n        run_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n    ```\n\n    Again with the target as `command`, `WATCHFILES_CHANGES` can be used\n    to access changes.\n\n    ```bash title=\"example.sh\"\n    echo \"changers: ${WATCHFILES_CHANGES}\"\n    ```\n\n    ```py title=\"Example of run_process running a command\"\n    from watchfiles import run_process\n\n    if __name__ == '__main__':\n        run_process('.', target='./example.sh')\n    ```\n    \"\"\"\n    if target_type == 'auto':\n        target_type = detect_target_type(target)\n\n    logger.debug('running \"%s\" as %s', target, target_type)\n    catch_sigterm()\n    process = start_process(target, target_type, args, kwargs)\n    reloads = 0\n\n    if grace_period:\n        logger.debug('sleeping for %s seconds before watching for changes', grace_period)\n        sleep(grace_period)\n\n    try:\n        for changes in watch(\n            *paths,\n            watch_filter=watch_filter,\n            debounce=debounce,\n            step=step,\n            debug=debug,\n            raise_interrupt=False,\n            recursive=recursive,\n            ignore_permission_denied=ignore_permission_denied,\n        ):\n            callback and callback(changes)\n            process.stop(sigint_timeout=sigint_timeout, sigkill_timeout=sigkill_timeout)\n            process = start_process(target, target_type, args, kwargs, changes)\n            reloads += 1\n    finally:\n        process.stop()\n    return reloads\n</code></pre> <p>Async equivalent of <code>run_process</code>, all arguments match those of <code>run_process</code> except <code>callback</code> which can be a coroutine.</p> <p>Starting and stopping the process and watching for changes is done in a separate thread.</p> <p>As with <code>run_process</code>, internally <code>arun_process</code> uses <code>awatch</code>, however <code>KeyboardInterrupt</code> cannot be caught and suppressed in <code>awatch</code> so these errors need to be caught separately, see below.</p> Example of arun_process usage<pre><code>import asyncio\nfrom watchfiles import arun_process\n\nasync def callback(changes):\n    await asyncio.sleep(0.1)\n    print('changes detected:', changes)\n\ndef foobar(a, b):\n    print('foobar called with:', a, b)\n\nasync def main():\n    await arun_process('.', target=foobar, args=(1, 2), callback=callback)\n\nif __name__ == '__main__':\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print('stopped via KeyboardInterrupt')\n</code></pre> Source code in <code>watchfiles/run.py</code> <pre><code>async def arun_process(\n    *paths: Union[Path, str],\n    target: Union[str, Callable[..., Any]],\n    args: Tuple[Any, ...] = (),\n    kwargs: Optional[Dict[str, Any]] = None,\n    target_type: \"Literal['function', 'command', 'auto']\" = 'auto',\n    callback: Optional[Callable[[Set[FileChange]], Any]] = None,\n    watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(),\n    grace_period: float = 0,\n    debounce: int = 1_600,\n    step: int = 50,\n    debug: bool = False,\n    recursive: bool = True,\n    ignore_permission_denied: bool = False,\n) -&gt; int:\n    \"\"\"\n    Async equivalent of [`run_process`][watchfiles.run_process], all arguments match those of `run_process` except\n    `callback` which can be a coroutine.\n\n    Starting and stopping the process and watching for changes is done in a separate thread.\n\n    As with `run_process`, internally `arun_process` uses [`awatch`][watchfiles.awatch], however `KeyboardInterrupt`\n    cannot be caught and suppressed in `awatch` so these errors need to be caught separately, see below.\n\n    ```py title=\"Example of arun_process usage\"\n    import asyncio\n    from watchfiles import arun_process\n\n    async def callback(changes):\n        await asyncio.sleep(0.1)\n        print('changes detected:', changes)\n\n    def foobar(a, b):\n        print('foobar called with:', a, b)\n\n    async def main():\n        await arun_process('.', target=foobar, args=(1, 2), callback=callback)\n\n    if __name__ == '__main__':\n        try:\n            asyncio.run(main())\n        except KeyboardInterrupt:\n            print('stopped via KeyboardInterrupt')\n    ```\n    \"\"\"\n    import inspect\n\n    if target_type == 'auto':\n        target_type = detect_target_type(target)\n\n    logger.debug('running \"%s\" as %s', target, target_type)\n    catch_sigterm()\n    process = await anyio.to_thread.run_sync(start_process, target, target_type, args, kwargs)\n    reloads = 0\n\n    if grace_period:\n        logger.debug('sleeping for %s seconds before watching for changes', grace_period)\n        await anyio.sleep(grace_period)\n\n    async for changes in awatch(\n        *paths,\n        watch_filter=watch_filter,\n        debounce=debounce,\n        step=step,\n        debug=debug,\n        recursive=recursive,\n        ignore_permission_denied=ignore_permission_denied,\n    ):\n        if callback is not None:\n            r = callback(changes)\n            if inspect.isawaitable(r):\n                await r\n\n        await anyio.to_thread.run_sync(process.stop)\n        process = await anyio.to_thread.run_sync(start_process, target, target_type, args, kwargs, changes)\n        reloads += 1\n    await anyio.to_thread.run_sync(process.stop)\n    return reloads\n</code></pre> <p>Used by <code>run_process</code>, <code>arun_process</code> and indirectly the CLI to determine the target type with <code>target_type</code> is <code>auto</code>.</p> <p>Detects the target type - either <code>function</code> or <code>command</code>. This method is only called with <code>target_type='auto'</code>.</p> <p>The following logic is employed:</p> <ul> <li>If <code>target</code> is not a string, it is assumed to be a function</li> <li>If <code>target</code> ends with <code>.py</code> or <code>.sh</code>, it is assumed to be a command</li> <li>Otherwise, the target is assumed to be a function if it matches the regex <code>[a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)+</code></li> </ul> <p>If this logic does not work for you, specify the target type explicitly using the <code>target_type</code> function argument or <code>--target-type</code> command line argument.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Union[str, Callable[..., Any]]</code> <p>The target value</p> required <p>Returns:</p> Type Description <code>Literal['function', 'command']</code> <p>either <code>'function'</code> or <code>'command'</code></p> Source code in <code>watchfiles/run.py</code> <pre><code>def detect_target_type(target: Union[str, Callable[..., Any]]) -&gt; \"Literal['function', 'command']\":\n    \"\"\"\n    Used by [`run_process`][watchfiles.run_process], [`arun_process`][watchfiles.arun_process]\n    and indirectly the CLI to determine the target type with `target_type` is `auto`.\n\n    Detects the target type - either `function` or `command`. This method is only called with `target_type='auto'`.\n\n    The following logic is employed:\n\n    * If `target` is not a string, it is assumed to be a function\n    * If `target` ends with `.py` or `.sh`, it is assumed to be a command\n    * Otherwise, the target is assumed to be a function if it matches the regex `[a-zA-Z0-9_]+(\\\\.[a-zA-Z0-9_]+)+`\n\n    If this logic does not work for you, specify the target type explicitly using the `target_type` function argument\n    or `--target-type` command line argument.\n\n    Args:\n        target: The target value\n\n    Returns:\n        either `'function'` or `'command'`\n    \"\"\"\n    if not isinstance(target, str):\n        return 'function'\n    elif target.endswith(('.py', '.sh')):\n        return 'command'\n    elif re.fullmatch(r'[a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)+', target):\n        return 'function'\n    else:\n        return 'command'\n</code></pre>"},{"location":"api/rust_backend/","title":"Rust backend direct usage","text":"<p>Interface to the Rust notify crate which does the heavy lifting of watching for file changes and grouping them into events.</p> Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>class RustNotify:\n    \"\"\"\n    Interface to the Rust [notify](https://crates.io/crates/notify) crate which does\n    the heavy lifting of watching for file changes and grouping them into events.\n    \"\"\"\n\n    def __init__(\n        self,\n        watch_paths: list[str],\n        debug: bool,\n        force_polling: bool,\n        poll_delay_ms: int,\n        recursive: bool,\n        ignore_permission_denied: bool,\n    ) -&gt; None:\n        \"\"\"\n        Create a new `RustNotify` instance and start a thread to watch for changes.\n\n        `FileNotFoundError` is raised if any of the paths do not exist.\n\n        Args:\n            watch_paths: file system paths to watch for changes, can be directories or files\n            debug: if true, print details about all events to stderr\n            force_polling: if true, always use polling instead of file system notifications\n            poll_delay_ms: delay between polling for changes, only used if `force_polling=True`\n            recursive: if `True`, watch for changes in sub-directories recursively, otherwise watch only for changes in\n                the top-level directory, default is `True`.\n            ignore_permission_denied: if `True`, permission denied errors are ignored while watching changes.\n        \"\"\"\n    def watch(\n        self,\n        debounce_ms: int,\n        step_ms: int,\n        timeout_ms: int,\n        stop_event: AbstractEvent | None,\n    ) -&gt; set[tuple[int, str]] | Literal['signal', 'stop', 'timeout']:\n        \"\"\"\n        Watch for changes.\n\n        This method will wait `timeout_ms` milliseconds for changes, but once a change is detected,\n        it will group changes and return in no more than `debounce_ms` milliseconds.\n\n        The GIL is released during a `step_ms` sleep on each iteration to avoid\n        blocking python.\n\n        Args:\n            debounce_ms: maximum time in milliseconds to group changes over before returning.\n            step_ms: time to wait for new changes in milliseconds, if no changes are detected\n                in this time, and at least one change has been detected, the changes are yielded.\n            timeout_ms: maximum time in milliseconds to wait for changes before returning,\n                `0` means wait indefinitely, `debounce_ms` takes precedence over `timeout_ms` once\n                a change is detected.\n            stop_event: event to check on every iteration to see if this function should return early.\n                The event should be an object which has an `is_set()` method which returns a boolean.\n\n        Returns:\n            See below.\n\n        Return values have the following meanings:\n\n        * Change details as a `set` of `(event_type, path)` tuples, the event types are ints which match\n          [`Change`][watchfiles.Change], `path` is a string representing the path of the file that changed\n        * `'signal'` string, if a signal was received\n        * `'stop'` string, if the `stop_event` was set\n        * `'timeout'` string, if `timeout_ms` was exceeded\n        \"\"\"\n    def __enter__(self) -&gt; RustNotify:\n        \"\"\"\n        Does nothing, but allows `RustNotify` to be used as a context manager.\n\n        !!! note\n\n            The watching thead is created when an instance is initiated, not on `__enter__`.\n        \"\"\"\n    def __exit__(self, *args: Any) -&gt; None:\n        \"\"\"\n        Calls [`close`][watchfiles._rust_notify.RustNotify.close].\n        \"\"\"\n    def close(self) -&gt; None:\n        \"\"\"\n        Stops the watching thread. After `close` is called, the `RustNotify` instance can no\n        longer be used, calls to [`watch`][watchfiles._rust_notify.RustNotify.watch] will raise a `RuntimeError`.\n\n        !!! note\n\n            `close` is not required, just deleting the `RustNotify` instance will kill the thread\n            implicitly.\n\n            As per [#163](https://github.com/samuelcolvin/watchfiles/issues/163) `close()` is only required because\n            in the event of an error, the traceback in `sys.exc_info` keeps a reference to `watchfiles.watch`'s\n            frame, so you can't rely on the `RustNotify` object being deleted, and thereby stopping\n            the watching thread.\n        \"\"\"\n</code></pre> <p>             Bases: <code>RuntimeError</code></p> <p>Raised when RustNotify encounters an unknown error.</p> <p>If you get this a lot, please check github issues and create a new issue if your problem is not discussed.</p> Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>class WatchfilesRustInternalError(RuntimeError):\n    \"\"\"\n    Raised when RustNotify encounters an unknown error.\n\n    If you get this a lot, please check [github](https://github.com/samuelcolvin/watchfiles/issues) issues\n    and create a new issue if your problem is not discussed.\n    \"\"\"\n</code></pre> <p>The package version as defined in <code>Cargo.toml</code>, modified to match python's versioning semantics.</p>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__enter__","title":"<code>__enter__()</code>","text":"<p>Does nothing, but allows <code>RustNotify</code> to be used as a context manager.</p> <p>Note</p> <p>The watching thead is created when an instance is initiated, not on <code>__enter__</code>.</p> Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>def __enter__(self) -&gt; RustNotify:\n    \"\"\"\n    Does nothing, but allows `RustNotify` to be used as a context manager.\n\n    !!! note\n\n        The watching thead is created when an instance is initiated, not on `__enter__`.\n    \"\"\"\n</code></pre>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__exit__","title":"<code>__exit__(*args)</code>","text":"<p>Calls <code>close</code>.</p> Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>def __exit__(self, *args: Any) -&gt; None:\n    \"\"\"\n    Calls [`close`][watchfiles._rust_notify.RustNotify.close].\n    \"\"\"\n</code></pre>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__init__","title":"<code>__init__(watch_paths, debug, force_polling, poll_delay_ms, recursive, ignore_permission_denied)</code>","text":"<p>Create a new <code>RustNotify</code> instance and start a thread to watch for changes.</p> <p><code>FileNotFoundError</code> is raised if any of the paths do not exist.</p> <p>Parameters:</p> Name Type Description Default <code>watch_paths</code> <code>list[str]</code> <p>file system paths to watch for changes, can be directories or files</p> required <code>debug</code> <code>bool</code> <p>if true, print details about all events to stderr</p> required <code>force_polling</code> <code>bool</code> <p>if true, always use polling instead of file system notifications</p> required <code>poll_delay_ms</code> <code>int</code> <p>delay between polling for changes, only used if <code>force_polling=True</code></p> required <code>recursive</code> <code>bool</code> <p>if <code>True</code>, watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is <code>True</code>.</p> required <code>ignore_permission_denied</code> <code>bool</code> <p>if <code>True</code>, permission denied errors are ignored while watching changes.</p> required Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>def __init__(\n    self,\n    watch_paths: list[str],\n    debug: bool,\n    force_polling: bool,\n    poll_delay_ms: int,\n    recursive: bool,\n    ignore_permission_denied: bool,\n) -&gt; None:\n    \"\"\"\n    Create a new `RustNotify` instance and start a thread to watch for changes.\n\n    `FileNotFoundError` is raised if any of the paths do not exist.\n\n    Args:\n        watch_paths: file system paths to watch for changes, can be directories or files\n        debug: if true, print details about all events to stderr\n        force_polling: if true, always use polling instead of file system notifications\n        poll_delay_ms: delay between polling for changes, only used if `force_polling=True`\n        recursive: if `True`, watch for changes in sub-directories recursively, otherwise watch only for changes in\n            the top-level directory, default is `True`.\n        ignore_permission_denied: if `True`, permission denied errors are ignored while watching changes.\n    \"\"\"\n</code></pre>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.close","title":"<code>close()</code>","text":"<p>Stops the watching thread. After <code>close</code> is called, the <code>RustNotify</code> instance can no longer be used, calls to <code>watch</code> will raise a <code>RuntimeError</code>.</p> <p>Note</p> <p><code>close</code> is not required, just deleting the <code>RustNotify</code> instance will kill the thread implicitly.</p> <p>As per #163 <code>close()</code> is only required because in the event of an error, the traceback in <code>sys.exc_info</code> keeps a reference to <code>watchfiles.watch</code>'s frame, so you can't rely on the <code>RustNotify</code> object being deleted, and thereby stopping the watching thread.</p> Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Stops the watching thread. After `close` is called, the `RustNotify` instance can no\n    longer be used, calls to [`watch`][watchfiles._rust_notify.RustNotify.watch] will raise a `RuntimeError`.\n\n    !!! note\n\n        `close` is not required, just deleting the `RustNotify` instance will kill the thread\n        implicitly.\n\n        As per [#163](https://github.com/samuelcolvin/watchfiles/issues/163) `close()` is only required because\n        in the event of an error, the traceback in `sys.exc_info` keeps a reference to `watchfiles.watch`'s\n        frame, so you can't rely on the `RustNotify` object being deleted, and thereby stopping\n        the watching thread.\n    \"\"\"\n</code></pre>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.watch","title":"<code>watch(debounce_ms, step_ms, timeout_ms, stop_event)</code>","text":"<p>Watch for changes.</p> <p>This method will wait <code>timeout_ms</code> milliseconds for changes, but once a change is detected, it will group changes and return in no more than <code>debounce_ms</code> milliseconds.</p> <p>The GIL is released during a <code>step_ms</code> sleep on each iteration to avoid blocking python.</p> <p>Parameters:</p> Name Type Description Default <code>debounce_ms</code> <code>int</code> <p>maximum time in milliseconds to group changes over before returning.</p> required <code>step_ms</code> <code>int</code> <p>time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded.</p> required <code>timeout_ms</code> <code>int</code> <p>maximum time in milliseconds to wait for changes before returning, <code>0</code> means wait indefinitely, <code>debounce_ms</code> takes precedence over <code>timeout_ms</code> once a change is detected.</p> required <code>stop_event</code> <code>AbstractEvent | None</code> <p>event to check on every iteration to see if this function should return early. The event should be an object which has an <code>is_set()</code> method which returns a boolean.</p> required <p>Returns:</p> Type Description <code>set[tuple[int, str]] | Literal['signal', 'stop', 'timeout']</code> <p>See below.</p> <p>Return values have the following meanings:</p> <ul> <li>Change details as a <code>set</code> of <code>(event_type, path)</code> tuples, the event types are ints which match   <code>Change</code>, <code>path</code> is a string representing the path of the file that changed</li> <li><code>'signal'</code> string, if a signal was received</li> <li><code>'stop'</code> string, if the <code>stop_event</code> was set</li> <li><code>'timeout'</code> string, if <code>timeout_ms</code> was exceeded</li> </ul> Source code in <code>watchfiles/_rust_notify.pyi</code> <pre><code>def watch(\n    self,\n    debounce_ms: int,\n    step_ms: int,\n    timeout_ms: int,\n    stop_event: AbstractEvent | None,\n) -&gt; set[tuple[int, str]] | Literal['signal', 'stop', 'timeout']:\n    \"\"\"\n    Watch for changes.\n\n    This method will wait `timeout_ms` milliseconds for changes, but once a change is detected,\n    it will group changes and return in no more than `debounce_ms` milliseconds.\n\n    The GIL is released during a `step_ms` sleep on each iteration to avoid\n    blocking python.\n\n    Args:\n        debounce_ms: maximum time in milliseconds to group changes over before returning.\n        step_ms: time to wait for new changes in milliseconds, if no changes are detected\n            in this time, and at least one change has been detected, the changes are yielded.\n        timeout_ms: maximum time in milliseconds to wait for changes before returning,\n            `0` means wait indefinitely, `debounce_ms` takes precedence over `timeout_ms` once\n            a change is detected.\n        stop_event: event to check on every iteration to see if this function should return early.\n            The event should be an object which has an `is_set()` method which returns a boolean.\n\n    Returns:\n        See below.\n\n    Return values have the following meanings:\n\n    * Change details as a `set` of `(event_type, path)` tuples, the event types are ints which match\n      [`Change`][watchfiles.Change], `path` is a string representing the path of the file that changed\n    * `'signal'` string, if a signal was received\n    * `'stop'` string, if the `stop_event` was set\n    * `'timeout'` string, if `timeout_ms` was exceeded\n    \"\"\"\n</code></pre>"},{"location":"api/rust_backend/#rust-backend-direct-usage","title":"Rust backend direct usage","text":"<p>The rust backend can be accessed directly as follows:</p> Rust backend example<pre><code>from watchfiles._rust_notify import RustNotify\n\nr = RustNotify(['first/path', 'second/path'], False, False, 0, True, False)\n\nchanges = r.watch(1_600, 50, 100, None)\nprint(changes)\n\nr.close()\n</code></pre> <p>Or using <code>RustNotify</code> as a context manager:</p> Rust backend context manager example<pre><code>from watchfiles._rust_notify import RustNotify\n\nwith RustNotify(['first/path', 'second/path'], False, False, 0, True, False) as r:\n    changes = r.watch(1_600, 50, 100, None)\n    print(changes)\n</code></pre> <p>(See the documentation on <code>close</code> above for when and why the context manager or <code>close</code> method are required.)</p>"},{"location":"api/watch/","title":"Watch","text":"<p>Watch one or more paths and yield a set of changes whenever files change.</p> <p>The paths watched can be directories or files, directories are watched recursively - changes in subdirectories are also detected.</p> <p>Asynchronous equivalent of <code>watch</code> using threads to wait for changes. Arguments match those of <code>watch</code> except <code>stop_event</code>.</p> <p>All async methods use anyio to run the event loop.</p> <p>Unlike <code>watch</code> <code>KeyboardInterrupt</code> cannot be suppressed by <code>awatch</code> so they need to be caught where <code>asyncio.run</code> or equivalent is called.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[Path, str]</code> <p>filesystem paths to watch.</p> <code>()</code> <code>watch_filter</code> <code>Optional[Callable[[Change, str], bool]]</code> <p>matches the same argument of <code>watch</code>.</p> <code>DefaultFilter()</code> <code>debounce</code> <code>int</code> <p>matches the same argument of <code>watch</code>.</p> <code>1600</code> <code>step</code> <code>int</code> <p>matches the same argument of <code>watch</code>.</p> <code>50</code> <code>stop_event</code> <code>Optional[AnyEvent]</code> <p><code>anyio.Event</code> which can be used to stop iteration, see example below.</p> <code>None</code> <code>rust_timeout</code> <code>Optional[int]</code> <p>matches the same argument of <code>watch</code>, except that <code>None</code> means use <code>1_000</code> on Windows and <code>5_000</code> on other platforms thus helping with exiting on <code>Ctrl+C</code> on Windows, see #110.</p> <code>None</code> <code>yield_on_timeout</code> <code>bool</code> <p>matches the same argument of <code>watch</code>.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>matches the same argument of <code>watch</code>.</p> <code>False</code> <code>raise_interrupt</code> <code>Optional[bool]</code> <p>This is deprecated, <code>KeyboardInterrupt</code> will cause this coroutine to be cancelled and then be raised by the top level <code>asyncio.run</code> call or equivalent, and should be caught there. See #136</p> <code>None</code> <code>force_polling</code> <code>Optional[bool]</code> <p>if true, always use polling instead of file system notifications, default is <code>None</code> where <code>force_polling</code> is set to <code>True</code> if the <code>WATCHFILES_FORCE_POLLING</code> environment variable exists.</p> <code>None</code> <code>poll_delay_ms</code> <code>int</code> <p>delay between polling for changes, only used if <code>force_polling=True</code>.</p> <code>300</code> <code>recursive</code> <code>bool</code> <p>if <code>True</code>, watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is <code>True</code>.</p> <code>True</code> <code>ignore_permission_denied</code> <code>Optional[bool]</code> <p>if <code>True</code>, will ignore permission denied errors, otherwise will raise them by default. Setting the <code>WATCHFILES_IGNORE_PERMISSION_DENIED</code> environment variable will set this value too.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncGenerator[Set[FileChange], None]</code> <p>The generator yields sets of <code>FileChange</code>s.</p> Example of awatch usage<pre><code>import asyncio\nfrom watchfiles import awatch\n\nasync def main():\n    async for changes in awatch('./first/dir', './second/dir'):\n        print(changes)\n\nif __name__ == '__main__':\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print('stopped via KeyboardInterrupt')\n</code></pre> Example of awatch usage with a stop event<pre><code>import asyncio\nfrom watchfiles import awatch\n\nasync def main():\n    stop_event = asyncio.Event()\n\n    async def stop_soon():\n        await asyncio.sleep(3)\n        stop_event.set()\n\n    stop_soon_task = asyncio.create_task(stop_soon())\n\n    async for changes in awatch('/path/to/dir', stop_event=stop_event):\n        print(changes)\n\n    # cleanup by awaiting the (now complete) stop_soon_task\n    await stop_soon_task\n\nasyncio.run(main())\n</code></pre> Source code in <code>watchfiles/main.py</code> <pre><code>async def awatch(  # C901\n    *paths: Union[Path, str],\n    watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(),\n    debounce: int = 1_600,\n    step: int = 50,\n    stop_event: Optional['AnyEvent'] = None,\n    rust_timeout: Optional[int] = None,\n    yield_on_timeout: bool = False,\n    debug: bool = False,\n    raise_interrupt: Optional[bool] = None,\n    force_polling: Optional[bool] = None,\n    poll_delay_ms: int = 300,\n    recursive: bool = True,\n    ignore_permission_denied: Optional[bool] = None,\n) -&gt; AsyncGenerator[Set[FileChange], None]:\n    \"\"\"\n    Asynchronous equivalent of [`watch`][watchfiles.watch] using threads to wait for changes.\n    Arguments match those of [`watch`][watchfiles.watch] except `stop_event`.\n\n    All async methods use [anyio](https://anyio.readthedocs.io/en/latest/) to run the event loop.\n\n    Unlike [`watch`][watchfiles.watch] `KeyboardInterrupt` cannot be suppressed by `awatch` so they need to be caught\n    where `asyncio.run` or equivalent is called.\n\n    Args:\n        *paths: filesystem paths to watch.\n        watch_filter: matches the same argument of [`watch`][watchfiles.watch].\n        debounce: matches the same argument of [`watch`][watchfiles.watch].\n        step: matches the same argument of [`watch`][watchfiles.watch].\n        stop_event: `anyio.Event` which can be used to stop iteration, see example below.\n        rust_timeout: matches the same argument of [`watch`][watchfiles.watch], except that `None` means\n            use `1_000` on Windows and `5_000` on other platforms thus helping with exiting on `Ctrl+C` on Windows,\n            see [#110](https://github.com/samuelcolvin/watchfiles/issues/110).\n        yield_on_timeout: matches the same argument of [`watch`][watchfiles.watch].\n        debug: matches the same argument of [`watch`][watchfiles.watch].\n        raise_interrupt: This is deprecated, `KeyboardInterrupt` will cause this coroutine to be cancelled and then\n            be raised by the top level `asyncio.run` call or equivalent, and should be caught there.\n            See [#136](https://github.com/samuelcolvin/watchfiles/issues/136)\n        force_polling: if true, always use polling instead of file system notifications, default is `None` where\n            `force_polling` is set to `True` if the `WATCHFILES_FORCE_POLLING` environment variable exists.\n        poll_delay_ms: delay between polling for changes, only used if `force_polling=True`.\n        recursive: if `True`, watch for changes in sub-directories recursively, otherwise watch only for changes in the\n            top-level directory, default is `True`.\n        ignore_permission_denied: if `True`, will ignore permission denied errors, otherwise will raise them by default.\n            Setting the `WATCHFILES_IGNORE_PERMISSION_DENIED` environment variable will set this value too.\n\n    Yields:\n        The generator yields sets of [`FileChange`][watchfiles.main.FileChange]s.\n\n    ```py title=\"Example of awatch usage\"\n    import asyncio\n    from watchfiles import awatch\n\n    async def main():\n        async for changes in awatch('./first/dir', './second/dir'):\n            print(changes)\n\n    if __name__ == '__main__':\n        try:\n            asyncio.run(main())\n        except KeyboardInterrupt:\n            print('stopped via KeyboardInterrupt')\n    ```\n\n    ```py title=\"Example of awatch usage with a stop event\"\n    import asyncio\n    from watchfiles import awatch\n\n    async def main():\n        stop_event = asyncio.Event()\n\n        async def stop_soon():\n            await asyncio.sleep(3)\n            stop_event.set()\n\n        stop_soon_task = asyncio.create_task(stop_soon())\n\n        async for changes in awatch('/path/to/dir', stop_event=stop_event):\n            print(changes)\n\n        # cleanup by awaiting the (now complete) stop_soon_task\n        await stop_soon_task\n\n    asyncio.run(main())\n    ```\n    \"\"\"\n    if raise_interrupt is not None:\n        warnings.warn(\n            'raise_interrupt is deprecated, KeyboardInterrupt will cause this coroutine to be cancelled and then '\n            'be raised by the top level asyncio.run call or equivalent, and should be caught there. See #136.',\n            DeprecationWarning,\n        )\n\n    if stop_event is None:\n        stop_event_: 'AnyEvent' = anyio.Event()\n    else:\n        stop_event_ = stop_event\n\n    force_polling = _default_force_polling(force_polling)\n    ignore_permission_denied = _default_ignore_permission_denied(ignore_permission_denied)\n    with RustNotify(\n        [str(p) for p in paths], debug, force_polling, poll_delay_ms, recursive, ignore_permission_denied\n    ) as watcher:\n        timeout = _calc_async_timeout(rust_timeout)\n        CancelledError = anyio.get_cancelled_exc_class()\n\n        while True:\n            async with anyio.create_task_group() as tg:\n                try:\n                    raw_changes = await anyio.to_thread.run_sync(watcher.watch, debounce, step, timeout, stop_event_)\n                except (CancelledError, KeyboardInterrupt):\n                    stop_event_.set()\n                    # suppressing KeyboardInterrupt wouldn't stop it getting raised by the top level asyncio.run call\n                    raise\n                tg.cancel_scope.cancel()\n\n            if raw_changes == 'timeout':\n                if yield_on_timeout:\n                    yield set()\n                else:\n                    logger.debug('rust notify timeout, continuing')\n            elif raw_changes == 'stop':\n                return\n            elif raw_changes == 'signal':\n                # in theory the watch thread should never get a signal\n                raise RuntimeError('watch thread unexpectedly received a signal')\n            else:\n                changes = _prep_changes(raw_changes, watch_filter)\n                if changes:\n                    _log_changes(changes)\n                    yield changes\n                else:\n                    logger.debug('all changes filtered out, raw_changes=%s', raw_changes)\n</code></pre> <p>             Bases: <code>IntEnum</code></p> <p>Enum representing the type of change that occurred.</p> Source code in <code>watchfiles/main.py</code> <pre><code>class Change(IntEnum):\n    \"\"\"\n    Enum representing the type of change that occurred.\n    \"\"\"\n\n    added = 1\n    \"\"\"A new file or directory was added.\"\"\"\n    modified = 2\n    \"\"\"A file or directory was modified, can be either a metadata or data change.\"\"\"\n    deleted = 3\n    \"\"\"A file or directory was deleted.\"\"\"\n\n    def raw_str(self) -&gt; str:\n        return self.name\n</code></pre> <p>A tuple representing a file change, first element is a <code>Change</code> member, second is the path of the file or directory that changed.</p>"},{"location":"api/watch/#watchfiles.watch--force-polling","title":"Force polling","text":"<p>Notify will fall back to file polling if it can't use file system notifications, but we also force notify to us polling if the <code>force_polling</code> argument is <code>True</code>; if <code>force_polling</code> is unset (or <code>None</code>), we enable force polling thus:</p> <ul> <li>if the <code>WATCHFILES_FORCE_POLLING</code> environment variable exists and is not empty:</li> <li>if the value is <code>false</code>, <code>disable</code> or <code>disabled</code>, force polling is disabled</li> <li>otherwise, force polling is enabled</li> <li>otherwise, we enable force polling only if we detect we're running on WSL (Windows Subsystem for Linux)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[Path, str]</code> <p>filesystem paths to watch.</p> <code>()</code> <code>watch_filter</code> <code>Optional[Callable[[Change, str], bool]]</code> <p>callable used to filter out changes which are not important, you can either use a raw callable or a <code>BaseFilter</code> instance, defaults to an instance of <code>DefaultFilter</code>. To keep all changes, use <code>None</code>.</p> <code>DefaultFilter()</code> <code>debounce</code> <code>int</code> <p>maximum time in milliseconds to group changes over before yielding them.</p> <code>1600</code> <code>step</code> <code>int</code> <p>time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded.</p> <code>50</code> <code>stop_event</code> <code>Optional[AbstractEvent]</code> <p>event to stop watching, if this is set, the generator will stop iteration, this can be anything with an <code>is_set()</code> method which returns a bool, e.g. <code>threading.Event()</code>.</p> <code>None</code> <code>rust_timeout</code> <code>int</code> <p>maximum time in milliseconds to wait in the rust code for changes, <code>0</code> means no timeout.</p> <code>5000</code> <code>yield_on_timeout</code> <code>bool</code> <p>if <code>True</code>, the generator will yield upon timeout in rust even if no changes are detected.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>whether to print information about all filesystem changes in rust to stdout.</p> <code>False</code> <code>raise_interrupt</code> <code>bool</code> <p>whether to re-raise <code>KeyboardInterrupt</code>s, or suppress the error and just stop iterating.</p> <code>True</code> <code>force_polling</code> <code>Optional[bool]</code> <p>See Force polling above.</p> <code>None</code> <code>poll_delay_ms</code> <code>int</code> <p>delay between polling for changes, only used if <code>force_polling=True</code>.</p> <code>300</code> <code>recursive</code> <code>bool</code> <p>if <code>True</code>, watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is <code>True</code>.</p> <code>True</code> <code>ignore_permission_denied</code> <code>Optional[bool]</code> <p>if <code>True</code>, will ignore permission denied errors, otherwise will raise them by default. Setting the <code>WATCHFILES_IGNORE_PERMISSION_DENIED</code> environment variable will set this value too.</p> <code>None</code> <p>Yields:</p> Type Description <code>Set[FileChange]</code> <p>The generator yields sets of <code>FileChange</code>s.</p> Example of watch usage<pre><code>from watchfiles import watch\n\nfor changes in watch('./first/dir', './second/dir', raise_interrupt=False):\n    print(changes)\n</code></pre> Source code in <code>watchfiles/main.py</code> <pre><code>def watch(\n    *paths: Union[Path, str],\n    watch_filter: Optional[Callable[['Change', str], bool]] = DefaultFilter(),\n    debounce: int = 1_600,\n    step: int = 50,\n    stop_event: Optional['AbstractEvent'] = None,\n    rust_timeout: int = 5_000,\n    yield_on_timeout: bool = False,\n    debug: bool = False,\n    raise_interrupt: bool = True,\n    force_polling: Optional[bool] = None,\n    poll_delay_ms: int = 300,\n    recursive: bool = True,\n    ignore_permission_denied: Optional[bool] = None,\n) -&gt; Generator[Set[FileChange], None, None]:\n    \"\"\"\n    Watch one or more paths and yield a set of changes whenever files change.\n\n    The paths watched can be directories or files, directories are watched recursively - changes in subdirectories\n    are also detected.\n\n    #### Force polling\n\n    Notify will fall back to file polling if it can't use file system notifications, but we also force notify\n    to us polling if the `force_polling` argument is `True`; if `force_polling` is unset (or `None`), we enable\n    force polling thus:\n\n    * if the `WATCHFILES_FORCE_POLLING` environment variable exists and is not empty:\n       * if the value is `false`, `disable` or `disabled`, force polling is disabled\n       * otherwise, force polling is enabled\n    * otherwise, we enable force polling only if we detect we're running on WSL (Windows Subsystem for Linux)\n\n    Args:\n        *paths: filesystem paths to watch.\n        watch_filter: callable used to filter out changes which are not important, you can either use a raw callable\n            or a [`BaseFilter`][watchfiles.BaseFilter] instance,\n            defaults to an instance of [`DefaultFilter`][watchfiles.DefaultFilter]. To keep all changes, use `None`.\n        debounce: maximum time in milliseconds to group changes over before yielding them.\n        step: time to wait for new changes in milliseconds, if no changes are detected in this time, and\n            at least one change has been detected, the changes are yielded.\n        stop_event: event to stop watching, if this is set, the generator will stop iteration,\n            this can be anything with an `is_set()` method which returns a bool, e.g. `threading.Event()`.\n        rust_timeout: maximum time in milliseconds to wait in the rust code for changes, `0` means no timeout.\n        yield_on_timeout: if `True`, the generator will yield upon timeout in rust even if no changes are detected.\n        debug: whether to print information about all filesystem changes in rust to stdout.\n        raise_interrupt: whether to re-raise `KeyboardInterrupt`s, or suppress the error and just stop iterating.\n        force_polling: See [Force polling](#force-polling) above.\n        poll_delay_ms: delay between polling for changes, only used if `force_polling=True`.\n        recursive: if `True`, watch for changes in sub-directories recursively, otherwise watch only for changes in the\n            top-level directory, default is `True`.\n        ignore_permission_denied: if `True`, will ignore permission denied errors, otherwise will raise them by default.\n            Setting the `WATCHFILES_IGNORE_PERMISSION_DENIED` environment variable will set this value too.\n\n    Yields:\n        The generator yields sets of [`FileChange`][watchfiles.main.FileChange]s.\n\n    ```py title=\"Example of watch usage\"\n    from watchfiles import watch\n\n    for changes in watch('./first/dir', './second/dir', raise_interrupt=False):\n        print(changes)\n    ```\n    \"\"\"\n    force_polling = _default_force_polling(force_polling)\n    ignore_permission_denied = _default_ignore_permission_denied(ignore_permission_denied)\n    with RustNotify(\n        [str(p) for p in paths], debug, force_polling, poll_delay_ms, recursive, ignore_permission_denied\n    ) as watcher:\n        while True:\n            raw_changes = watcher.watch(debounce, step, rust_timeout, stop_event)\n            if raw_changes == 'timeout':\n                if yield_on_timeout:\n                    yield set()\n                else:\n                    logger.debug('rust notify timeout, continuing')\n            elif raw_changes == 'signal':\n                if raise_interrupt:\n                    raise KeyboardInterrupt\n                else:\n                    logger.warning('KeyboardInterrupt caught, stopping watch')\n                    return\n            elif raw_changes == 'stop':\n                return\n            else:\n                changes = _prep_changes(raw_changes, watch_filter)\n                if changes:\n                    _log_changes(changes)\n                    yield changes\n                else:\n                    logger.debug('all changes filtered out, raw_changes=%s', raw_changes)\n</code></pre>"},{"location":"api/watch/#watchfiles.Change.added","title":"<code>added = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A new file or directory was added.</p>"},{"location":"api/watch/#watchfiles.Change.deleted","title":"<code>deleted = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A file or directory was deleted.</p>"},{"location":"api/watch/#watchfiles.Change.modified","title":"<code>modified = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A file or directory was modified, can be either a metadata or data change.</p>"}]}